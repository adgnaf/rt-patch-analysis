 include/linux/hrtimer.h |   10 ++++++++++
 kernel/hrtimer.c        |   33 ++++++++++++++++++++++++++++++++-
 kernel/itimer.c         |    1 +
 kernel/posix-timers.c   |    3 +++
 4 files changed, 46 insertions(+), 1 deletion(-)

Index: linux-2.6.25.4-rt1/include/linux/hrtimer.h
===================================================================
--- linux-2.6.25.4-rt1.orig/include/linux/hrtimer.h	2008-05-17 08:27:01.000000000 -0400
+++ linux-2.6.25.4-rt1/include/linux/hrtimer.h	2008-05-17 08:27:09.000000000 -0400
@@ -197,6 +197,9 @@ struct hrtimer_cpu_base {
 	int				hres_active;
 	unsigned long			nr_events;
 #endif
+#ifdef CONFIG_PREEMPT_SOFTIRQS
+	wait_queue_head_t		wait;
+#endif
 };
 
 #ifdef CONFIG_HIGH_RES_TIMERS
@@ -279,6 +282,13 @@ static inline int hrtimer_restart(struct
 	return hrtimer_start(timer, timer->expires, HRTIMER_MODE_ABS);
 }
 
+/* Softirq preemption could deadlock timer removal */
+#ifdef CONFIG_PREEMPT_SOFTIRQS
+  extern void hrtimer_wait_for_timer(const struct hrtimer *timer);
+#else
+# define hrtimer_wait_for_timer(timer)	do { cpu_relax(); } while (0)
+#endif
+
 /* Query timers: */
 extern ktime_t hrtimer_get_remaining(const struct hrtimer *timer);
 extern int hrtimer_get_res(const clockid_t which_clock, struct timespec *tp);
Index: linux-2.6.25.4-rt1/kernel/hrtimer.c
===================================================================
--- linux-2.6.25.4-rt1.orig/kernel/hrtimer.c	2008-05-17 08:27:01.000000000 -0400
+++ linux-2.6.25.4-rt1/kernel/hrtimer.c	2008-05-17 08:27:09.000000000 -0400
@@ -973,7 +973,7 @@ int hrtimer_cancel(struct hrtimer *timer
 
 		if (ret >= 0)
 			return ret;
-		cpu_relax();
+		hrtimer_wait_for_timer(timer);
 	}
 }
 EXPORT_SYMBOL_GPL(hrtimer_cancel);
@@ -1085,6 +1085,32 @@ int hrtimer_get_res(const clockid_t whic
 }
 EXPORT_SYMBOL_GPL(hrtimer_get_res);
 
+#ifdef CONFIG_PREEMPT_SOFTIRQS
+# define wake_up_timer_waiters(b)	wake_up(&(b)->wait)
+
+/**
+ * hrtimer_wait_for_timer - Wait for a running timer
+ *
+ * @timer:	timer to wait for
+ *
+ * The function waits in case the timers callback function is
+ * currently executed on the waitqueue of the timer base. The
+ * waitqueue is woken up after the timer callback function has
+ * finished execution.
+ */
+void hrtimer_wait_for_timer(const struct hrtimer *timer)
+{
+	struct hrtimer_clock_base *base = timer->base;
+
+	if (base && base->cpu_base)
+		wait_event(base->cpu_base->wait,
+				!(timer->state & HRTIMER_STATE_CALLBACK));
+}
+
+#else
+# define wake_up_timer_waiters(b)	do { } while (0)
+#endif
+
 static void run_hrtimer_pending(struct hrtimer_cpu_base *cpu_base)
 {
 	spin_lock_irq(&cpu_base->lock);
@@ -1136,6 +1162,8 @@ static void run_hrtimer_pending(struct h
 		}
 	}
 	spin_unlock_irq(&cpu_base->lock);
+
+	wake_up_timer_waiters(cpu_base);
 }
 
 static void __run_hrtimer(struct hrtimer *timer)
@@ -1486,6 +1514,9 @@ static void __cpuinit init_hrtimers_cpu(
 
 	INIT_LIST_HEAD(&cpu_base->cb_pending);
 	hrtimer_init_hres(cpu_base);
+#ifdef CONFIG_PREEMPT_SOFTIRQS
+	init_waitqueue_head(&cpu_base->wait);
+#endif
 }
 
 #ifdef CONFIG_HOTPLUG_CPU
Index: linux-2.6.25.4-rt1/kernel/itimer.c
===================================================================
--- linux-2.6.25.4-rt1.orig/kernel/itimer.c	2008-05-17 08:26:38.000000000 -0400
+++ linux-2.6.25.4-rt1/kernel/itimer.c	2008-05-17 08:27:09.000000000 -0400
@@ -170,6 +170,7 @@ again:
 		/* We are sharing ->siglock with it_real_fn() */
 		if (hrtimer_try_to_cancel(timer) < 0) {
 			spin_unlock_irq(&tsk->sighand->siglock);
+			hrtimer_wait_for_timer(&tsk->signal->real_timer);
 			goto again;
 		}
 		expires = timeval_to_ktime(value->it_value);
Index: linux-2.6.25.4-rt1/kernel/posix-timers.c
===================================================================
--- linux-2.6.25.4-rt1.orig/kernel/posix-timers.c	2008-05-17 08:26:38.000000000 -0400
+++ linux-2.6.25.4-rt1/kernel/posix-timers.c	2008-05-17 08:27:09.000000000 -0400
@@ -810,6 +810,7 @@ retry:
 
 	unlock_timer(timr, flag);
 	if (error == TIMER_RETRY) {
+		hrtimer_wait_for_timer(&timr->it.real.timer);
 		rtn = NULL;	// We already got the old time...
 		goto retry;
 	}
@@ -849,6 +850,7 @@ retry_delete:
 
 	if (timer_delete_hook(timer) == TIMER_RETRY) {
 		unlock_timer(timer, flags);
+		hrtimer_wait_for_timer(&timer->it.real.timer);
 		goto retry_delete;
 	}
 
@@ -881,6 +883,7 @@ retry_delete:
 
 	if (timer_delete_hook(timer) == TIMER_RETRY) {
 		unlock_timer(timer, flags);
+		hrtimer_wait_for_timer(&timer->it.real.timer);
 		goto retry_delete;
 	}
 	list_del(&timer->list);
