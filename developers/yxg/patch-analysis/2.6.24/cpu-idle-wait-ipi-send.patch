From: Steven Rostedt <srostedt@redhat.com>
Subject: [PATCH] cpu_idle_wait handle CPUs in idle

Sometimes cpu_idle_wait gets stuck because it might miss
CPUS that are already in idle, have no tasks waiting to run
and have no interrupts going to them.  This is common on
bootup when switching cpu idle governors.

This patch gives those CPUS that don't check in an IPI kick.

Signed-off-by: Steven Rostedt <srostedt@redhat.com>
---
 arch/x86/kernel/process_32.c |   11 +++++++++++
 arch/x86/kernel/process_64.c |   11 +++++++++++
 2 files changed, 22 insertions(+)

Index: linux-2.6.24-rc7-rt3/arch/x86/kernel/process_32.c
===================================================================
--- linux-2.6.24-rc7-rt3.orig/arch/x86/kernel/process_32.c	2008-01-15 21:47:50.000000000 -0500
+++ linux-2.6.24-rc7-rt3/arch/x86/kernel/process_32.c	2008-01-15 21:47:50.000000000 -0500
@@ -204,6 +204,10 @@ void cpu_idle(void)
 	}
 }
 
+static void do_nothing(void *unused)
+{
+}
+
 void cpu_idle_wait(void)
 {
 	unsigned int cpu, this_cpu = get_cpu();
@@ -228,6 +232,13 @@ void cpu_idle_wait(void)
 				cpu_clear(cpu, map);
 		}
 		cpus_and(map, map, cpu_online_map);
+		/*
+		 * We waited 1 sec, if a CPU still did not call idle
+		 * it may be because it is in idle and not waking up
+		 * because it has nothing to do.
+		 * Give all the remaining CPUS a kick.
+		 */
+		smp_call_function_mask(map, do_nothing, 0, 0);
 	} while (!cpus_empty(map));
 
 	set_cpus_allowed(current, tmp);
Index: linux-2.6.24-rc7-rt3/arch/x86/kernel/process_64.c
===================================================================
--- linux-2.6.24-rc7-rt3.orig/arch/x86/kernel/process_64.c	2008-01-15 21:47:50.000000000 -0500
+++ linux-2.6.24-rc7-rt3/arch/x86/kernel/process_64.c	2008-01-15 21:47:50.000000000 -0500
@@ -135,6 +135,10 @@ static void poll_idle (void)
 	cpu_relax();
 }
 
+static void do_nothing(void *unused)
+{
+}
+
 void cpu_idle_wait(void)
 {
 	unsigned int cpu, this_cpu = get_cpu();
@@ -160,6 +164,13 @@ void cpu_idle_wait(void)
 				cpu_clear(cpu, map);
 		}
 		cpus_and(map, map, cpu_online_map);
+		/*
+		 * We waited 1 sec, if a CPU still did not call idle
+		 * it may be because it is in idle and not waking up
+		 * because it has nothing to do.
+		 * Give all the remaining CPUS a kick.
+		 */
+		smp_call_function_mask(map, do_nothing, 0, 0);
 	} while (!cpus_empty(map));
 
 	set_cpus_allowed(current, tmp);
