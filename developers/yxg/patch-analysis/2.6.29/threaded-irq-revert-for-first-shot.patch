---
 include/linux/hardirq.h   |    2 
 include/linux/interrupt.h |   63 ---------------
 include/linux/irq.h       |    5 -
 include/linux/irqreturn.h |    2 
 include/linux/sched.h     |    5 -
 kernel/exit.c             |    2 
 kernel/irq/devres.c       |   16 +--
 kernel/irq/handle.c       |   50 ------------
 kernel/irq/manage.c       |  189 +++-------------------------------------------
 9 files changed, 22 insertions(+), 312 deletions(-)

Index: linux-2.6-tip/include/linux/hardirq.h
===================================================================
--- linux-2.6-tip.orig/include/linux/hardirq.h
+++ linux-2.6-tip/include/linux/hardirq.h
@@ -116,7 +116,7 @@
 # define IRQ_EXIT_OFFSET HARDIRQ_OFFSET
 #endif
 
-#if defined(CONFIG_SMP) || defined(CONFIG_GENERIC_HARDIRQS)
+#ifdef CONFIG_SMP
 extern void synchronize_irq(unsigned int irq);
 #else
 # define synchronize_irq(irq)	barrier()
Index: linux-2.6-tip/include/linux/interrupt.h
===================================================================
--- linux-2.6-tip.orig/include/linux/interrupt.h
+++ linux-2.6-tip/include/linux/interrupt.h
@@ -59,18 +59,6 @@
 #define IRQF_NOBALANCING	0x00000800
 #define IRQF_IRQPOLL		0x00001000
 
-/*
- * Bits used by threaded handlers:
- * IRQTF_RUNTHREAD - signals that the interrupt handler thread should run
- * IRQTF_DIED      - handler thread died
- * IRQTF_WARNED    - warning "IRQ_WAKE_THREAD w/o thread_fn" has been printed
- */
-enum {
-	IRQTF_RUNTHREAD,
-	IRQTF_DIED,
-	IRQTF_WARNED,
-};
-
 typedef irqreturn_t (*irq_handler_t)(int, void *);
 
 /**
@@ -83,9 +71,6 @@ typedef irqreturn_t (*irq_handler_t)(int
  * @next:	pointer to the next irqaction for shared interrupts
  * @irq:	interrupt number
  * @dir:	pointer to the proc/irq/NN/name entry
- * @thread_fn:	interupt handler function for threaded interrupts
- * @thread:	thread pointer for threaded interrupts
- * @thread_flags:	flags related to @thread
  */
 struct irqaction {
 	irq_handler_t handler;
@@ -96,67 +81,21 @@ struct irqaction {
 	struct irqaction *next;
 	int irq;
 	struct proc_dir_entry *dir;
-	irq_handler_t thread_fn;
-	struct task_struct *thread;
-	unsigned long thread_flags;
 };
 
 extern irqreturn_t no_action(int cpl, void *dev_id);
 
-#ifdef CONFIG_GENERIC_HARDIRQS
-extern int __must_check
-request_threaded_irq(unsigned int irq, irq_handler_t handler,
-		     irq_handler_t thread_fn,
-		     unsigned long flags, const char *name, void *dev);
-
-static inline int __must_check
-request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
-	    const char *name, void *dev)
-{
-	return request_threaded_irq(irq, handler, NULL, flags, name, dev);
-}
-
-extern void exit_irq_thread(void);
-#else
-
 extern int __must_check
 request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
 	    const char *name, void *dev);
 
-/*
- * Special function to avoid ifdeffery in kernel/irq/devres.c which
- * gets magically built by GENERIC_HARDIRQS=n architectures (sparc,
- * m68k). I really love these $@%#!* obvious Makefile references:
- * ../../../kernel/irq/devres.o
- */
-static inline int __must_check
-request_threaded_irq(unsigned int irq, irq_handler_t handler,
-		     irq_handler_t thread_fn,
-		     unsigned long flags, const char *name, void *dev)
-{
-	return request_irq(irq, handler, flags, name, dev);
-}
-
-static inline void exit_irq_thread(void) { }
-#endif
-
 extern void free_irq(unsigned int, void *);
 
 struct device;
 
 extern int __must_check
-devm_request_threaded_irq(struct device *dev, unsigned int irq,
-			  irq_handler_t handler, irq_handler_t thread_fn,
-			  unsigned long irqflags, const char *devname,
-			  void *dev_id);
-
-static inline int __must_check
 devm_request_irq(struct device *dev, unsigned int irq, irq_handler_t handler,
-		 unsigned long irqflags, const char *devname, void *dev_id)
-{
-	return devm_request_threaded_irq(dev, irq, handler, NULL, irqflags,
-					 devname, dev_id);
-}
+		 unsigned long irqflags, const char *devname, void *dev_id);
 
 extern void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id);
 
Index: linux-2.6-tip/include/linux/irq.h
===================================================================
--- linux-2.6-tip.orig/include/linux/irq.h
+++ linux-2.6-tip/include/linux/irq.h
@@ -20,7 +20,6 @@
 #include <linux/irqreturn.h>
 #include <linux/irqnr.h>
 #include <linux/errno.h>
-#include <linux/wait.h>
 
 #include <asm/irq.h>
 #include <asm/ptrace.h>
@@ -156,8 +155,6 @@ struct irq_2_iommu;
  * @affinity:		IRQ affinity on SMP
  * @cpu:		cpu index useful for balancing
  * @pending_mask:	pending rebalanced interrupts
- * @threads_active:	number of irqaction threads currently running
- * @wait_for_threads:	wait queue for sync_irq to wait for threaded handlers
  * @dir:		/proc/irq/ procfs entry
  * @name:		flow handler name for /proc/interrupts output
  */
@@ -189,8 +186,6 @@ struct irq_desc {
 	cpumask_var_t		pending_mask;
 #endif
 #endif
-	atomic_t		threads_active;
-	wait_queue_head_t       wait_for_threads;
 #ifdef CONFIG_PROC_FS
 	struct proc_dir_entry	*dir;
 #endif
Index: linux-2.6-tip/include/linux/irqreturn.h
===================================================================
--- linux-2.6-tip.orig/include/linux/irqreturn.h
+++ linux-2.6-tip/include/linux/irqreturn.h
@@ -5,12 +5,10 @@
  * enum irqreturn
  * @IRQ_NONE		interrupt was not from this device
  * @IRQ_HANDLED		interrupt was handled by this device
- * @IRQ_WAKE_THREAD	handler requests to wake the handler thread
  */
 enum irqreturn {
 	IRQ_NONE,
 	IRQ_HANDLED,
-	IRQ_WAKE_THREAD,
 };
 
 typedef enum irqreturn irqreturn_t;
Index: linux-2.6-tip/include/linux/sched.h
===================================================================
--- linux-2.6-tip.orig/include/linux/sched.h
+++ linux-2.6-tip/include/linux/sched.h
@@ -1306,11 +1306,6 @@ struct task_struct {
 /* Protection of (de-)allocation: mm, files, fs, tty, keyrings */
 	spinlock_t alloc_lock;
 
-#ifdef CONFIG_GENERIC_HARDIRQS
-	/* IRQ handler threads */
-	struct irqaction *irqaction;
-#endif
-
 	/* Protection of the PI data structures: */
 	spinlock_t pi_lock;
 
Index: linux-2.6-tip/kernel/exit.c
===================================================================
--- linux-2.6-tip.orig/kernel/exit.c
+++ linux-2.6-tip/kernel/exit.c
@@ -1040,8 +1040,6 @@ NORET_TYPE void do_exit(long code)
 		schedule();
 	}
 
-	exit_irq_thread();
-
 	exit_signals(tsk);  /* sets PF_EXITING */
 	/*
 	 * tsk->flags are checked in the futex code to protect against
Index: linux-2.6-tip/kernel/irq/devres.c
===================================================================
--- linux-2.6-tip.orig/kernel/irq/devres.c
+++ linux-2.6-tip/kernel/irq/devres.c
@@ -26,12 +26,10 @@ static int devm_irq_match(struct device 
 }
 
 /**
- *	devm_request_threaded_irq - allocate an interrupt line for a managed device
+ *	devm_request_irq - allocate an interrupt line for a managed device
  *	@dev: device to request interrupt for
  *	@irq: Interrupt line to allocate
  *	@handler: Function to be called when the IRQ occurs
- *	@thread_fn: function to be called in a threaded interrupt context. NULL
- *		    for devices which handle everything in @handler
  *	@irqflags: Interrupt type flags
  *	@devname: An ascii name for the claiming device
  *	@dev_id: A cookie passed back to the handler function
@@ -44,10 +42,9 @@ static int devm_irq_match(struct device 
  *	If an IRQ allocated with this function needs to be freed
  *	separately, dev_free_irq() must be used.
  */
-int devm_request_threaded_irq(struct device *dev, unsigned int irq,
-			      irq_handler_t handler, irq_handler_t thread_fn,
-			      unsigned long irqflags, const char *devname,
-			      void *dev_id)
+int devm_request_irq(struct device *dev, unsigned int irq,
+		     irq_handler_t handler, unsigned long irqflags,
+		     const char *devname, void *dev_id)
 {
 	struct irq_devres *dr;
 	int rc;
@@ -57,8 +54,7 @@ int devm_request_threaded_irq(struct dev
 	if (!dr)
 		return -ENOMEM;
 
-	rc = request_threaded_irq(irq, handler, thread_fn, irqflags, devname,
-				  dev_id);
+	rc = request_irq(irq, handler, irqflags, devname, dev_id);
 	if (rc) {
 		devres_free(dr);
 		return rc;
@@ -70,7 +66,7 @@ int devm_request_threaded_irq(struct dev
 
 	return 0;
 }
-EXPORT_SYMBOL(devm_request_threaded_irq);
+EXPORT_SYMBOL(devm_request_irq);
 
 /**
  *	devm_free_irq - free an interrupt
Index: linux-2.6-tip/kernel/irq/handle.c
===================================================================
--- linux-2.6-tip.orig/kernel/irq/handle.c
+++ linux-2.6-tip/kernel/irq/handle.c
@@ -339,15 +339,6 @@ irqreturn_t no_action(int cpl, void *dev
 	return IRQ_NONE;
 }
 
-static void warn_no_thread(unsigned int irq, struct irqaction *action)
-{
-	if (test_and_set_bit(IRQTF_WARNED, &action->thread_flags))
-		return;
-
-	printk(KERN_WARNING "IRQ %d device %s returned IRQ_WAKE_THREAD "
-	       "but no thread function available.", irq, action->name);
-}
-
 DEFINE_TRACE(irq_handler_entry);
 DEFINE_TRACE(irq_handler_exit);
 
@@ -372,47 +363,8 @@ irqreturn_t handle_IRQ_event(unsigned in
 		trace_irq_handler_entry(irq, action);
 		ret = action->handler(irq, action->dev_id);
 		trace_irq_handler_exit(irq, action, ret);
-
-		switch (ret) {
-		case IRQ_WAKE_THREAD:
-			/*
-			 * Set result to handled so the spurious check
-			 * does not trigger.
-			 */
-			ret = IRQ_HANDLED;
-
-			/*
-			 * Catch drivers which return WAKE_THREAD but
-			 * did not set up a thread function
-			 */
-			if (unlikely(!action->thread_fn)) {
-				warn_no_thread(irq, action);
-				break;
-			}
-
-			/*
-			 * Wake up the handler thread for this
-			 * action. In case the thread crashed and was
-			 * killed we just pretend that we handled the
-			 * interrupt. The hardirq handler above has
-			 * disabled the device interrupt, so no irq
-			 * storm is lurking.
-			 */
-			if (likely(!test_bit(IRQTF_DIED,
-					     &action->thread_flags))) {
-				set_bit(IRQTF_RUNTHREAD, &action->thread_flags);
-				wake_up_process(action->thread);
-			}
-
-			/* Fall through to add to randomness */
-		case IRQ_HANDLED:
+		if (ret == IRQ_HANDLED)
 			status |= action->flags;
-			break;
-
-		default:
-			break;
-		}
-
 		retval |= ret;
 		action = action->next;
 	} while (action);
Index: linux-2.6-tip/kernel/irq/manage.c
===================================================================
--- linux-2.6-tip.orig/kernel/irq/manage.c
+++ linux-2.6-tip/kernel/irq/manage.c
@@ -8,15 +8,16 @@
  */
 
 #include <linux/irq.h>
-#include <linux/kthread.h>
 #include <linux/module.h>
 #include <linux/random.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
-#include <linux/sched.h>
 
 #include "internals.h"
 
+#if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_HARDIRQS)
+cpumask_var_t irq_default_affinity;
+
 /**
  *	synchronize_irq - wait for pending IRQ handlers (on other CPUs)
  *	@irq: interrupt number to wait for
@@ -52,18 +53,9 @@ void synchronize_irq(unsigned int irq)
 
 		/* Oops, that failed? */
 	} while (status & IRQ_INPROGRESS);
-
-	/*
-	 * We made sure that no hardirq handler is running. Now verify
-	 * that no threaded handlers are active.
-	 */
-	wait_event(desc->wait_for_threads, !atomic_read(&desc->threads_active));
 }
 EXPORT_SYMBOL(synchronize_irq);
 
-#ifdef CONFIG_SMP
-cpumask_var_t irq_default_affinity;
-
 /**
  *	irq_can_set_affinity - Check if the affinity of a given irq can be set
  *	@irq:		Interrupt to check
@@ -80,18 +72,6 @@ int irq_can_set_affinity(unsigned int ir
 	return 1;
 }
 
-static void
-irq_set_thread_affinity(struct irq_desc *desc, const struct cpumask *cpumask)
-{
-	struct irqaction *action = desc->action;
-
-	while (action) {
-		if (action->thread)
-			set_cpus_allowed_ptr(action->thread, cpumask);
-		action = action->next;
-	}
-}
-
 /**
  *	irq_set_affinity - Set the irq affinity of a given irq
  *	@irq:		Interrupt to set affinity
@@ -120,7 +100,6 @@ int irq_set_affinity(unsigned int irq, c
 	cpumask_copy(desc->affinity, cpumask);
 	desc->chip->set_affinity(irq, cpumask);
 #endif
-	irq_set_thread_affinity(desc, cpumask);
 	desc->status |= IRQ_AFFINITY_SET;
 	spin_unlock_irqrestore(&desc->lock, flags);
 	return 0;
@@ -171,8 +150,6 @@ int irq_select_affinity_usr(unsigned int
 
 	spin_lock_irqsave(&desc->lock, flags);
 	ret = setup_affinity(irq, desc);
-	if (!ret)
-		irq_set_thread_affinity(desc, desc->affinity);
 	spin_unlock_irqrestore(&desc->lock, flags);
 
 	return ret;
@@ -407,90 +384,6 @@ int __irq_set_trigger(struct irq_desc *d
 	return ret;
 }
 
-static int irq_wait_for_interrupt(struct irqaction *action)
-{
-	while (!kthread_should_stop()) {
-		set_current_state(TASK_INTERRUPTIBLE);
-
-		if (test_and_clear_bit(IRQTF_RUNTHREAD,
-				       &action->thread_flags)) {
-			__set_current_state(TASK_RUNNING);
-			return 0;
-		}
-		schedule();
-	}
-	return -1;
-}
-
-/*
- * Interrupt handler thread
- */
-static int irq_thread(void *data)
-{
-	struct sched_param param = { .sched_priority = MAX_USER_RT_PRIO/2, };
-	struct irqaction *action = data;
-	struct irq_desc *desc = irq_to_desc(action->irq);
-	int wake;
-
-	sched_setscheduler(current, SCHED_FIFO, &param);
-	current->irqaction = action;
-
-	while (!irq_wait_for_interrupt(action)) {
-
-		atomic_inc(&desc->threads_active);
-
-		spin_lock_irq(&desc->lock);
-		if (unlikely(desc->status & IRQ_DISABLED)) {
-			/*
-			 * CHECKME: We might need a dedicated
-			 * IRQ_THREAD_PENDING flag here, which
-			 * retriggers the thread in check_irq_resend()
-			 * but AFAICT IRQ_PENDING should be fine as it
-			 * retriggers the interrupt itself --- tglx
-			 */
-			desc->status |= IRQ_PENDING;
-			spin_unlock_irq(&desc->lock);
-		} else {
-			spin_unlock_irq(&desc->lock);
-
-			action->thread_fn(action->irq, action->dev_id);
-		}
-
-		wake = atomic_dec_and_test(&desc->threads_active);
-
-		if (wake && waitqueue_active(&desc->wait_for_threads))
-			wake_up(&desc->wait_for_threads);
-	}
-
-	/*
-	 * Clear irqaction. Otherwise exit_irq_thread() would make
-	 * fuzz about an active irq thread going into nirvana.
-	 */
-	current->irqaction = NULL;
-	return 0;
-}
-
-/*
- * Called from do_exit()
- */
-void exit_irq_thread(void)
-{
-	struct task_struct *tsk = current;
-
-	if (!tsk->irqaction)
-		return;
-
-	printk(KERN_ERR
-	       "exiting task \"%s\" (%d) is an active IRQ thread (irq %d)\n",
-	       tsk->comm ? tsk->comm : "", tsk->pid, tsk->irqaction->irq);
-
-	/*
-	 * Set the THREAD DIED flag to prevent further wakeups of the
-	 * soon to be gone threaded handler.
-	 */
-	set_bit(IRQTF_DIED, &tsk->irqaction->flags);
-}
-
 /*
  * Internal function to register an irqaction - typically used to
  * allocate special interrupts that are part of the architecture.
@@ -527,26 +420,6 @@ __setup_irq(unsigned int irq, struct irq
 	}
 
 	/*
-	 * Threaded handler ?
-	 */
-	if (new->thread_fn) {
-		struct task_struct *t;
-
-		t = kthread_create(irq_thread, new, "irq/%d-%s", irq,
-				   new->name);
-		if (IS_ERR(t))
-			return PTR_ERR(t);
-		/*
-		 * We keep the reference to the task struct even if
-		 * the thread dies to avoid that the interrupt code
-		 * references an already freed task_struct.
-		 */
-		get_task_struct(t);
-		new->thread = t;
-		wake_up_process(t);
-	}
-
-	/*
 	 * The following block of code has to be executed atomically
 	 */
 	spin_lock_irqsave(&desc->lock, flags);
@@ -583,15 +456,15 @@ __setup_irq(unsigned int irq, struct irq
 	if (!shared) {
 		irq_chip_set_defaults(desc->chip);
 
-		init_waitqueue_head(&desc->wait_for_threads);
-
 		/* Setup the type (level, edge polarity) if configured: */
 		if (new->flags & IRQF_TRIGGER_MASK) {
 			ret = __irq_set_trigger(desc, irq,
 					new->flags & IRQF_TRIGGER_MASK);
 
-			if (ret)
-				goto out_thread;
+			if (ret) {
+				spin_unlock_irqrestore(&desc->lock, flags);
+				return ret;
+			}
 		} else
 			compat_irq_chip_set_default_handler(desc);
 #if defined(CONFIG_IRQ_PER_CPU)
@@ -659,19 +532,8 @@ mismatch:
 		dump_stack();
 	}
 #endif
-	ret = -EBUSY;
-
-out_thread:
 	spin_unlock_irqrestore(&desc->lock, flags);
-	if (new->thread) {
-		struct task_struct *t = new->thread;
-
-		new->thread = NULL;
-		if (likely(!test_bit(IRQTF_DIED, &new->thread_flags)))
-			kthread_stop(t);
-		put_task_struct(t);
-	}
-	return ret;
+	return -EBUSY;
 }
 
 /**
@@ -697,7 +559,6 @@ static struct irqaction *__free_irq(unsi
 {
 	struct irq_desc *desc = irq_to_desc(irq);
 	struct irqaction *action, **action_ptr;
-	struct task_struct *irqthread;
 	unsigned long flags;
 
 	WARN(in_interrupt(), "Trying to free IRQ %d from IRQ context!\n", irq);
@@ -744,10 +605,6 @@ static struct irqaction *__free_irq(unsi
 		else
 			desc->chip->disable(irq);
 	}
-
-	irqthread = action->thread;
-	action->thread = NULL;
-
 	spin_unlock_irqrestore(&desc->lock, flags);
 
 	unregister_handler_proc(irq, action);
@@ -755,12 +612,6 @@ static struct irqaction *__free_irq(unsi
 	/* Make sure it's not being used on another CPU: */
 	synchronize_irq(irq);
 
-	if (irqthread) {
-		if (!test_bit(IRQTF_DIED, &action->thread_flags))
-			kthread_stop(irqthread);
-		put_task_struct(irqthread);
-	}
-
 #ifdef CONFIG_DEBUG_SHIRQ
 	/*
 	 * It's a shared IRQ -- the driver ought to be prepared for an IRQ
@@ -813,12 +664,9 @@ void free_irq(unsigned int irq, void *de
 EXPORT_SYMBOL(free_irq);
 
 /**
- *	request_threaded_irq - allocate an interrupt line
+ *	request_irq - allocate an interrupt line
  *	@irq: Interrupt line to allocate
- *	@handler: Function to be called when the IRQ occurs.
- *		  Primary handler for threaded interrupts
- *	@thread_fn: Function called from the irq handler thread
- *		    If NULL, no irq thread is created
+ *	@handler: Function to be called when the IRQ occurs
  *	@irqflags: Interrupt type flags
  *	@devname: An ascii name for the claiming device
  *	@dev_id: A cookie passed back to the handler function
@@ -830,15 +678,6 @@ EXPORT_SYMBOL(free_irq);
  *	raises, you must take care both to initialise your hardware
  *	and to set up the interrupt handler in the right order.
  *
- *	If you want to set up a threaded irq handler for your device
- *	then you need to supply @handler and @thread_fn. @handler ist
- *	still called in hard interrupt context and has to check
- *	whether the interrupt originates from the device. If yes it
- *	needs to disable the interrupt on the device and return
- *	IRQ_THREAD_WAKE which will wake up the handler thread and run
- *	@thread_fn. This split handler design is necessary to support
- *	shared interrupts.
- *
  *	Dev_id must be globally unique. Normally the address of the
  *	device data structure is used as the cookie. Since the handler
  *	receives this value it makes sense to use it.
@@ -854,9 +693,8 @@ EXPORT_SYMBOL(free_irq);
  *	IRQF_TRIGGER_*		Specify active edge(s) or level
  *
  */
-int request_threaded_irq(unsigned int irq, irq_handler_t handler,
-			 irq_handler_t thread_fn, unsigned long irqflags,
-			 const char *devname, void *dev_id)
+int request_irq(unsigned int irq, irq_handler_t handler,
+		unsigned long irqflags, const char *devname, void *dev_id)
 {
 	struct irqaction *action;
 	struct irq_desc *desc;
@@ -904,7 +742,6 @@ int request_threaded_irq(unsigned int ir
 		return -ENOMEM;
 
 	action->handler = handler;
-	action->thread_fn = thread_fn;
 	action->flags = irqflags;
 	action->name = devname;
 	action->dev_id = dev_id;
@@ -934,4 +771,4 @@ int request_threaded_irq(unsigned int ir
 #endif
 	return retval;
 }
-EXPORT_SYMBOL(request_threaded_irq);
+EXPORT_SYMBOL(request_irq);
