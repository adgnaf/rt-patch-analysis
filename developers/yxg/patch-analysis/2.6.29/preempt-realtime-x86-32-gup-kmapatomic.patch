Subject: preempt-realtime-x86-32-gup-kmapatomic.patch
From: Thomas Gleixner <tglx@linutronix.de>
Date: Mon, 16 Feb 2009 10:27:37 +0100

Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
---
 arch/x86/include/asm/highmem.h    |    8 +++++++-
 arch/x86/include/asm/paravirt.h   |    9 +++++++++
 arch/x86/include/asm/pgtable_32.h |    6 ++++++
 arch/x86/include/asm/pgtable_64.h |    6 ++++--
 arch/x86/kernel/paravirt.c        |    5 +++++
 arch/x86/mm/gup.c                 |    6 +++---
 arch/x86/mm/highmem_32.c          |    5 +++++
 7 files changed, 39 insertions(+), 6 deletions(-)

Index: linux-2.6-tip/arch/x86/include/asm/highmem.h
===================================================================
--- linux-2.6-tip.orig/arch/x86/include/asm/highmem.h
+++ linux-2.6-tip/arch/x86/include/asm/highmem.h
@@ -64,6 +64,7 @@ void kunmap(struct page *page);
 
 void *__kmap_atomic_prot(struct page *page, enum km_type type, pgprot_t prot);
 void *__kmap_atomic(struct page *page, enum km_type type);
+void *__kmap_atomic_direct(struct page *page, enum km_type type);
 void __kunmap_atomic(void *kvaddr, enum km_type type);
 void *__kmap_atomic_pfn(unsigned long pfn, enum km_type type);
 struct page *__kmap_atomic_to_page(void *ptr);
@@ -77,7 +78,8 @@ void *kmap_atomic_prot_pfn(unsigned long
 struct page *kmap_atomic_to_page(void *ptr);
 
 #ifndef CONFIG_PARAVIRT
-#define kmap_atomic_pte(page, type)	kmap_atomic(page, type)
+#define kmap_atomic_pte(page, type)		kmap_atomic(page, type)
+#define kmap_atomic_pte_direct(page, type)	kmap_atomic_direct(page, type)
 #endif
 
 #define flush_cache_kmaps()	do { } while (0)
@@ -94,12 +96,16 @@ extern void add_highpages_with_active_re
 # define kmap_atomic_pfn(pfn, type)	kmap(pfn_to_page(pfn))
 # define kunmap_atomic(kvaddr, type)	do { pagefault_enable(); kunmap_virt(kvaddr); } while(0)
 # define kmap_atomic_to_page(kvaddr)	kmap_to_page(kvaddr)
+# define kmap_atomic_direct(page, type)	__kmap_atomic_direct(page, type)
+# define kunmap_atomic_direct(kvaddr, type)	__kunmap_atomic(kvaddr, type)
 #else
 # define kmap_atomic_prot(page, type, prot)	__kmap_atomic_prot(page, type, prot)
 # define kmap_atomic(page, type)	__kmap_atomic(page, type)
 # define kmap_atomic_pfn(pfn, type)	__kmap_atomic_pfn(pfn, type)
 # define kunmap_atomic(kvaddr, type)	__kunmap_atomic(kvaddr, type)
 # define kmap_atomic_to_page(kvaddr)	__kmap_atomic_to_page(kvaddr)
+# define kmap_atomic_direct(page, type)	__kmap_atomic(page, type)
+# define kunmap_atomic_direct(kvaddr, type)	__kunmap_atomic(kvaddr, type)
 #endif
 
 #endif /* __KERNEL__ */
Index: linux-2.6-tip/arch/x86/include/asm/paravirt.h
===================================================================
--- linux-2.6-tip.orig/arch/x86/include/asm/paravirt.h
+++ linux-2.6-tip/arch/x86/include/asm/paravirt.h
@@ -338,6 +338,7 @@ struct pv_mmu_ops {
 
 #ifdef CONFIG_HIGHPTE
 	void *(*kmap_atomic_pte)(struct page *page, enum km_type type);
+	void *(*kmap_atomic_pte_direct)(struct page *page, enum km_type type);
 #endif
 
 	struct pv_lazy_ops lazy_mode;
@@ -1134,6 +1135,14 @@ static inline void *kmap_atomic_pte(stru
 	ret = PVOP_CALL2(unsigned long, pv_mmu_ops.kmap_atomic_pte, page, type);
 	return (void *)ret;
 }
+
+static inline void *kmap_atomic_pte_direct(struct page *page, enum km_type type)
+{
+	unsigned long ret;
+	ret = PVOP_CALL2(unsigned long, pv_mmu_ops.kmap_atomic_pte_direct,
+			 page, type);
+	return (void *)ret;
+}
 #endif
 
 static inline void pte_update(struct mm_struct *mm, unsigned long addr,
Index: linux-2.6-tip/arch/x86/include/asm/pgtable_32.h
===================================================================
--- linux-2.6-tip.orig/arch/x86/include/asm/pgtable_32.h
+++ linux-2.6-tip/arch/x86/include/asm/pgtable_32.h
@@ -55,14 +55,20 @@ extern void set_pmd_pfn(unsigned long, u
 #define pte_offset_map_nested(dir, address)				\
 	((pte_t *)kmap_atomic_pte(pmd_page(*(dir)), KM_PTE1) +		\
 	 pte_index((address)))
+#define pte_offset_map_direct(dir, address)				\
+	((pte_t *)kmap_atomic_pte_direct(pmd_page(*(dir)), KM_PTE0) +	\
+	 pte_index((address)))
 #define pte_unmap(pte) kunmap_atomic((pte), KM_PTE0)
 #define pte_unmap_nested(pte) kunmap_atomic((pte), KM_PTE1)
+#define pte_unmap_direct(pte) kunmap_atomic_direct((pte), KM_PTE0)
 #else
 #define pte_offset_map(dir, address)					\
 	((pte_t *)page_address(pmd_page(*(dir))) + pte_index((address)))
 #define pte_offset_map_nested(dir, address) pte_offset_map((dir), (address))
+#define pte_offset_map_direct(dir, address) pte_offset_map((dir), (address))
 #define pte_unmap(pte) do { } while (0)
 #define pte_unmap_nested(pte) do { } while (0)
+#define pte_unmap_direct(pte) do { } while (0)
 #endif
 
 /* Clear a kernel PTE and flush it from the TLB */
Index: linux-2.6-tip/arch/x86/include/asm/pgtable_64.h
===================================================================
--- linux-2.6-tip.orig/arch/x86/include/asm/pgtable_64.h
+++ linux-2.6-tip/arch/x86/include/asm/pgtable_64.h
@@ -130,8 +130,10 @@ static inline int pgd_large(pgd_t pgd) {
 /* x86-64 always has all page tables mapped. */
 #define pte_offset_map(dir, address) pte_offset_kernel((dir), (address))
 #define pte_offset_map_nested(dir, address) pte_offset_kernel((dir), (address))
-#define pte_unmap(pte) /* NOP */
-#define pte_unmap_nested(pte) /* NOP */
+#define pte_offset_map_direct(dir, address) pte_offset_kernel((dir), (address))
+#define pte_unmap(pte) do { } while (0)
+#define pte_unmap_nested(pte) do { }  while (0)
+#define pte_unmap_direct(pte) do { }  while (0)
 
 #define update_mmu_cache(vma, address, pte) do { } while (0)
 
Index: linux-2.6-tip/arch/x86/kernel/paravirt.c
===================================================================
--- linux-2.6-tip.orig/arch/x86/kernel/paravirt.c
+++ linux-2.6-tip/arch/x86/kernel/paravirt.c
@@ -432,6 +432,10 @@ static void *kmap_atomic_func(struct pag
 {
 	return kmap_atomic(page, idx);
 }
+static void *kmap_atomic_direct_func(struct page *page, enum km_type idx)
+{
+	return kmap_atomic_direct(page, idx);
+}
 #endif
 
 struct pv_mmu_ops pv_mmu_ops = {
@@ -475,6 +479,7 @@ struct pv_mmu_ops pv_mmu_ops = {
 
 #ifdef CONFIG_HIGHPTE
 	.kmap_atomic_pte = kmap_atomic_func,
+	.kmap_atomic_pte_direct = kmap_atomic_direct_func,
 #endif
 
 #if PAGETABLE_LEVELS >= 3
Index: linux-2.6-tip/arch/x86/mm/gup.c
===================================================================
--- linux-2.6-tip.orig/arch/x86/mm/gup.c
+++ linux-2.6-tip/arch/x86/mm/gup.c
@@ -77,13 +77,13 @@ static noinline int gup_pte_range(pmd_t 
 	if (write)
 		mask |= _PAGE_RW;
 
-	ptep = pte_offset_map(&pmd, addr);
+	ptep = pte_offset_map_direct(&pmd, addr);
 	do {
 		pte_t pte = gup_get_pte(ptep);
 		struct page *page;
 
 		if ((pte_flags(pte) & (mask | _PAGE_SPECIAL)) != mask) {
-			pte_unmap(ptep);
+			pte_unmap_direct(ptep);
 			return 0;
 		}
 		VM_BUG_ON(!pfn_valid(pte_pfn(pte)));
@@ -93,7 +93,7 @@ static noinline int gup_pte_range(pmd_t 
 		(*nr)++;
 
 	} while (ptep++, addr += PAGE_SIZE, addr != end);
-	pte_unmap(ptep - 1);
+	pte_unmap_direct(ptep - 1);
 
 	return 1;
 }
Index: linux-2.6-tip/arch/x86/mm/highmem_32.c
===================================================================
--- linux-2.6-tip.orig/arch/x86/mm/highmem_32.c
+++ linux-2.6-tip/arch/x86/mm/highmem_32.c
@@ -113,6 +113,11 @@ void *__kmap_atomic_prot(struct page *pa
 	return (void *)vaddr;
 }
 
+void *__kmap_atomic_direct(struct page *page, enum km_type type)
+{
+	return __kmap_atomic_prot(page, type, kmap_prot);
+}
+
 void *__kmap_atomic(struct page *page, enum km_type type)
 {
 	return kmap_atomic_prot(page, type, kmap_prot);
