Subject: Don't let -rt rw_semaphors do _non_owner locks
From: Steven Rostedt <rostedt@goodmis.org>
Date: Tue, 25 Sep 2007 11:29:51 -0400 (EDT)

--
On Tue, 25 Sep 2007, Peter Zijlstra wrote:

> How about teaching {up,down}_read_non_owner() to barf on rw_semaphore
> in -rt?
>

Sure thing!

This patch prevents rw_semaphore in PREEMPT_RT from performing
down_read_non_owner and up_read_non_owner. If this must be used, then
either convert to a completion or use compat_rw_semaphore.

Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

Signed-off-by: Ingo Molnar <mingo@elte.hu>
---
 include/linux/rt_lock.h |   15 +++++----------
 kernel/rt.c             |   45 ---------------------------------------------
 2 files changed, 5 insertions(+), 55 deletions(-)

Index: linux-2.6-tip/include/linux/rt_lock.h
===================================================================
--- linux-2.6-tip.orig/include/linux/rt_lock.h
+++ linux-2.6-tip/include/linux/rt_lock.h
@@ -205,25 +205,20 @@ do {							\
 	__rt_rwsem_init((sem), #sem, &__key);		\
 } while (0)
 
+extern void __dont_do_this_in_rt(struct rw_semaphore *rwsem);
+
+#define rt_down_read_non_owner(rwsem)	__dont_do_this_in_rt(rwsem)
+#define rt_up_read_non_owner(rwsem)	__dont_do_this_in_rt(rwsem)
+
 extern void  rt_down_write(struct rw_semaphore *rwsem);
 extern void
 rt_down_read_nested(struct rw_semaphore *rwsem, int subclass);
 extern void
 rt_down_write_nested(struct rw_semaphore *rwsem, int subclass);
 extern void  rt_down_read(struct rw_semaphore *rwsem);
-#ifdef CONFIG_DEBUG_LOCK_ALLOC
-extern void  rt_down_read_non_owner(struct rw_semaphore *rwsem);
-#else
-# define rt_down_read_non_owner(rwsem)		rt_down_read(rwsem)
-#endif
 extern int  rt_down_write_trylock(struct rw_semaphore *rwsem);
 extern int  rt_down_read_trylock(struct rw_semaphore *rwsem);
 extern void  rt_up_read(struct rw_semaphore *rwsem);
-#ifdef CONFIG_DEBUG_LOCK_ALLOC
-extern void  rt_up_read_non_owner(struct rw_semaphore *rwsem);
-#else
-# define rt_up_read_non_owner(rwsem)	rt_up_read(rwsem)
-#endif
 extern void  rt_up_write(struct rw_semaphore *rwsem);
 extern void  rt_downgrade_write(struct rw_semaphore *rwsem);
 
Index: linux-2.6-tip/kernel/rt.c
===================================================================
--- linux-2.6-tip.orig/kernel/rt.c
+++ linux-2.6-tip/kernel/rt.c
@@ -342,25 +342,6 @@ void  rt_up_read(struct rw_semaphore *rw
 }
 EXPORT_SYMBOL(rt_up_read);
 
-#ifdef CONFIG_DEBUG_LOCK_ALLOC
-void  rt_up_read_non_owner(struct rw_semaphore *rwsem)
-{
-	unsigned long flags;
-	/*
-	 * Read locks within the self-held write lock succeed.
-	 */
-	spin_lock_irqsave(&rwsem->lock.wait_lock, flags);
-	if (rt_mutex_real_owner(&rwsem->lock) == current && rwsem->read_depth) {
-		spin_unlock_irqrestore(&rwsem->lock.wait_lock, flags);
-		rwsem->read_depth--;
-		return;
-	}
-	spin_unlock_irqrestore(&rwsem->lock.wait_lock, flags);
-	rt_mutex_unlock(&rwsem->lock);
-}
-EXPORT_SYMBOL(rt_up_read_non_owner);
-#endif
-
 /*
  * downgrade a write lock into a read lock
  * - just wake up any readers at the front of the queue
@@ -451,32 +432,6 @@ void  rt_down_read_nested(struct rw_sema
 }
 EXPORT_SYMBOL(rt_down_read_nested);
 
-
-#ifdef CONFIG_DEBUG_LOCK_ALLOC
-
-/*
- * Same as rt_down_read() but no lockdep calls:
- */
-void  rt_down_read_non_owner(struct rw_semaphore *rwsem)
-{
-	unsigned long flags;
-	/*
-	 * Read locks within the write lock succeed.
-	 */
-	spin_lock_irqsave(&rwsem->lock.wait_lock, flags);
-
-	if (rt_mutex_real_owner(&rwsem->lock) == current) {
-		spin_unlock_irqrestore(&rwsem->lock.wait_lock, flags);
-		rwsem->read_depth++;
-		return;
-	}
-	spin_unlock_irqrestore(&rwsem->lock.wait_lock, flags);
-	rt_mutex_lock(&rwsem->lock);
-}
-EXPORT_SYMBOL(rt_down_read_non_owner);
-
-#endif
-
 void  __rt_rwsem_init(struct rw_semaphore *rwsem, char *name,
 			      struct lock_class_key *key)
 {
