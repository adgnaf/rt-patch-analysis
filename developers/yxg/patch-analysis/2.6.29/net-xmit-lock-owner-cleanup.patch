Subject: net: xmit lock owner cleanup
From: Ingo Molnar <mingo@elte.hu>
Date: Sun Feb 08 08:17:14 CET 2009

- __netif_tx_lock() always passes in 'current' as the lock owner,
  so eliminate this parameter.

- likewise for HARD_TX_LOCK()

Signed-off-by: Ingo Molnar <mingo@elte.hu>
---
 drivers/net/bnx2.c        |    2 +-
 drivers/net/mv643xx_eth.c |    6 +++---
 drivers/net/niu.c         |    2 +-
 include/linux/netdevice.h |   24 ++++++++++++++----------
 net/core/dev.c            |    4 ++--
 net/core/netpoll.c        |    2 +-
 net/sched/sch_generic.c   |    4 ++--
 7 files changed, 24 insertions(+), 20 deletions(-)

Index: linux-2.6-tip/drivers/net/bnx2.c
===================================================================
--- linux-2.6-tip.orig/drivers/net/bnx2.c
+++ linux-2.6-tip/drivers/net/bnx2.c
@@ -2661,7 +2661,7 @@ bnx2_tx_int(struct bnx2 *bp, struct bnx2
 
 	if (unlikely(netif_tx_queue_stopped(txq)) &&
 		     (bnx2_tx_avail(bp, txr) > bp->tx_wake_thresh)) {
-		__netif_tx_lock(txq, (void *)current);
+		__netif_tx_lock(txq);
 		if ((netif_tx_queue_stopped(txq)) &&
 		    (bnx2_tx_avail(bp, txr) > bp->tx_wake_thresh))
 			netif_tx_wake_queue(txq);
Index: linux-2.6-tip/drivers/net/mv643xx_eth.c
===================================================================
--- linux-2.6-tip.orig/drivers/net/mv643xx_eth.c
+++ linux-2.6-tip/drivers/net/mv643xx_eth.c
@@ -484,7 +484,7 @@ static void txq_maybe_wake(struct tx_que
 	struct netdev_queue *nq = netdev_get_tx_queue(mp->dev, txq->index);
 
 	if (netif_tx_queue_stopped(nq)) {
-		__netif_tx_lock(nq, (void *)current);
+		__netif_tx_lock(nq);
 		if (txq->tx_ring_size - txq->tx_desc_count >= MAX_SKB_FRAGS + 1)
 			netif_tx_wake_queue(nq);
 		__netif_tx_unlock(nq);
@@ -838,7 +838,7 @@ static void txq_kick(struct tx_queue *tx
 	u32 hw_desc_ptr;
 	u32 expected_ptr;
 
-	__netif_tx_lock(nq, (void *)current);
+	__netif_tx_lock(nq);
 
 	if (rdlp(mp, TXQ_COMMAND) & (1 << txq->index))
 		goto out;
@@ -862,7 +862,7 @@ static int txq_reclaim(struct tx_queue *
 	struct netdev_queue *nq = netdev_get_tx_queue(mp->dev, txq->index);
 	int reclaimed;
 
-	__netif_tx_lock(nq, (void *)current);
+	__netif_tx_lock(nq);
 
 	reclaimed = 0;
 	while (reclaimed < budget && txq->tx_desc_count > 0) {
Index: linux-2.6-tip/drivers/net/niu.c
===================================================================
--- linux-2.6-tip.orig/drivers/net/niu.c
+++ linux-2.6-tip/drivers/net/niu.c
@@ -3519,7 +3519,7 @@ static void niu_tx_work(struct niu *np, 
 out:
 	if (unlikely(netif_tx_queue_stopped(txq) &&
 		     (niu_tx_avail(rp) > NIU_TX_WAKEUP_THRESH(rp)))) {
-		__netif_tx_lock(txq, (void *)current);
+		__netif_tx_lock(txq);
 		if (netif_tx_queue_stopped(txq) &&
 		    (niu_tx_avail(rp) > NIU_TX_WAKEUP_THRESH(rp)))
 			netif_tx_wake_queue(txq);
Index: linux-2.6-tip/include/linux/netdevice.h
===================================================================
--- linux-2.6-tip.orig/include/linux/netdevice.h
+++ linux-2.6-tip/include/linux/netdevice.h
@@ -1625,10 +1625,18 @@ static inline void netif_rx_complete(str
 	napi_complete(napi);
 }
 
-static inline void __netif_tx_lock(struct netdev_queue *txq, void *curr)
+static inline void __netif_tx_lock(struct netdev_queue *txq)
 {
 	spin_lock(&txq->_xmit_lock);
-	txq->xmit_lock_owner = curr;
+	txq->xmit_lock_owner = (void *)current;
+}
+
+/*
+ * Do we hold the xmit_lock already?
+ */
+static inline int netif_tx_lock_recursion(struct netdev_queue *txq)
+{
+	return txq->xmit_lock_owner == (void *)current;
 }
 
 static inline void __netif_tx_lock_bh(struct netdev_queue *txq)
@@ -1666,10 +1674,8 @@ static inline void __netif_tx_unlock_bh(
 static inline void netif_tx_lock(struct net_device *dev)
 {
 	unsigned int i;
-	void *curr;
 
 	spin_lock(&dev->tx_global_lock);
-	curr = (void *)current;
 	for (i = 0; i < dev->num_tx_queues; i++) {
 		struct netdev_queue *txq = netdev_get_tx_queue(dev, i);
 
@@ -1679,7 +1685,7 @@ static inline void netif_tx_lock(struct 
 		 * the ->hard_start_xmit() handler and already
 		 * checked the frozen bit.
 		 */
-		__netif_tx_lock(txq, curr);
+		__netif_tx_lock(txq);
 		set_bit(__QUEUE_STATE_FROZEN, &txq->state);
 		__netif_tx_unlock(txq);
 	}
@@ -1715,9 +1721,9 @@ static inline void netif_tx_unlock_bh(st
 	local_bh_enable();
 }
 
-#define HARD_TX_LOCK(dev, txq, curr) {			\
+#define HARD_TX_LOCK(dev, txq) {			\
 	if ((dev->features & NETIF_F_LLTX) == 0) {	\
-		__netif_tx_lock(txq, curr);		\
+		__netif_tx_lock(txq);			\
 	}						\
 }
 
@@ -1730,14 +1736,12 @@ static inline void netif_tx_unlock_bh(st
 static inline void netif_tx_disable(struct net_device *dev)
 {
 	unsigned int i;
-	void *curr;
 
 	local_bh_disable();
-	curr = (void *)current;
 	for (i = 0; i < dev->num_tx_queues; i++) {
 		struct netdev_queue *txq = netdev_get_tx_queue(dev, i);
 
-		__netif_tx_lock(txq, curr);
+		__netif_tx_lock(txq);
 		netif_tx_stop_queue(txq);
 		__netif_tx_unlock(txq);
 	}
Index: linux-2.6-tip/net/core/dev.c
===================================================================
--- linux-2.6-tip.orig/net/core/dev.c
+++ linux-2.6-tip/net/core/dev.c
@@ -1884,9 +1884,9 @@ gso:
 		/*
 		 * No need to check for recursion with threaded interrupts:
 		 */
-		if (txq->xmit_lock_owner != (void *)current) {
+		if (!netif_tx_lock_recursion(txq)) {
 
-			HARD_TX_LOCK(dev, txq, (void *)current);
+			HARD_TX_LOCK(dev, txq);
 
 			if (!netif_tx_queue_stopped(txq)) {
 				rc = 0;
Index: linux-2.6-tip/net/core/netpoll.c
===================================================================
--- linux-2.6-tip.orig/net/core/netpoll.c
+++ linux-2.6-tip/net/core/netpoll.c
@@ -69,7 +69,7 @@ static void queue_process(struct work_st
 		txq = netdev_get_tx_queue(dev, skb_get_queue_mapping(skb));
 
 		local_irq_save_nort(flags);
-		__netif_tx_lock(txq, (void *)current);
+		__netif_tx_lock(txq);
 		if (netif_tx_queue_stopped(txq) ||
 		    netif_tx_queue_frozen(txq) ||
 		    ops->ndo_start_xmit(skb, dev) != NETDEV_TX_OK) {
Index: linux-2.6-tip/net/sched/sch_generic.c
===================================================================
--- linux-2.6-tip.orig/net/sched/sch_generic.c
+++ linux-2.6-tip/net/sched/sch_generic.c
@@ -80,7 +80,7 @@ static inline int handle_dev_cpu_collisi
 {
 	int ret;
 
-	if (unlikely(dev_queue->xmit_lock_owner == (void *)current)) {
+	if (unlikely(netif_tx_lock_recursion(dev_queue))) {
 		/*
 		 * Same CPU holding the lock. It may be a transient
 		 * configuration error, when hard_start_xmit() recurses. We
@@ -143,7 +143,7 @@ static inline int qdisc_restart(struct Q
 	dev = qdisc_dev(q);
 	txq = netdev_get_tx_queue(dev, skb_get_queue_mapping(skb));
 
-	HARD_TX_LOCK(dev, txq, (void *)current);
+	HARD_TX_LOCK(dev, txq);
 	if (!netif_tx_queue_stopped(txq) &&
 	    !netif_tx_queue_frozen(txq))
 		ret = dev_hard_start_xmit(skb, dev, txq);
