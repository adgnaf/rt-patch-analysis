Subject: preempt: realtime acpi
From: Ingo Molnar <mingo@elte.hu>
Date: Wed Feb 04 00:02:52 CET 2009

Signed-off-by: Ingo Molnar <mingo@elte.hu>
---
 drivers/acpi/acpica/acglobal.h |    7 ++++++-
 drivers/acpi/acpica/hwregs.c   |    4 ++--
 drivers/acpi/acpica/hwxface.c  |    8 ++++----
 drivers/acpi/acpica/utmutex.c  |    2 +-
 drivers/acpi/ec.c              |   15 ++++++++++++++-
 drivers/acpi/processor_idle.c  |    2 +-
 include/acpi/acpiosxf.h        |    2 +-
 7 files changed, 29 insertions(+), 11 deletions(-)

Index: linux-2.6-tip/drivers/acpi/acpica/acglobal.h
===================================================================
--- linux-2.6-tip.orig/drivers/acpi/acpica/acglobal.h
+++ linux-2.6-tip/drivers/acpi/acpica/acglobal.h
@@ -190,7 +190,12 @@ ACPI_EXTERN u8 acpi_gbl_global_lock_pres
  * interrupt level
  */
 ACPI_EXTERN spinlock_t _acpi_gbl_gpe_lock;	/* For GPE data structs and registers */
-ACPI_EXTERN spinlock_t _acpi_gbl_hardware_lock;	/* For ACPI H/W except GPE registers */
+
+/*
+ * Need to be raw because it might be used in acpi_processor_idle():
+ */
+ACPI_EXTERN raw_spinlock_t _acpi_gbl_hardware_lock;	/* For ACPI H/W except GPE registers */
+
 #define acpi_gbl_gpe_lock	&_acpi_gbl_gpe_lock
 #define acpi_gbl_hardware_lock	&_acpi_gbl_hardware_lock
 
Index: linux-2.6-tip/drivers/acpi/acpica/hwregs.c
===================================================================
--- linux-2.6-tip.orig/drivers/acpi/acpica/hwregs.c
+++ linux-2.6-tip/drivers/acpi/acpica/hwregs.c
@@ -74,7 +74,7 @@ acpi_status acpi_hw_clear_acpi_status(vo
 			  ACPI_BITMASK_ALL_FIXED_STATUS,
 			  (u16) acpi_gbl_FADT.xpm1a_event_block.address));
 
-	lock_flags = acpi_os_acquire_lock(acpi_gbl_hardware_lock);
+	spin_lock_irqsave(acpi_gbl_hardware_lock, lock_flags);
 
 	status = acpi_hw_register_write(ACPI_REGISTER_PM1_STATUS,
 					ACPI_BITMASK_ALL_FIXED_STATUS);
@@ -97,7 +97,7 @@ acpi_status acpi_hw_clear_acpi_status(vo
 	status = acpi_ev_walk_gpe_list(acpi_hw_clear_gpe_block, NULL);
 
       unlock_and_exit:
-	acpi_os_release_lock(acpi_gbl_hardware_lock, lock_flags);
+	spin_unlock_irqrestore(acpi_gbl_hardware_lock, lock_flags);
 	return_ACPI_STATUS(status);
 }
 
Index: linux-2.6-tip/drivers/acpi/acpica/hwxface.c
===================================================================
--- linux-2.6-tip.orig/drivers/acpi/acpica/hwxface.c
+++ linux-2.6-tip/drivers/acpi/acpica/hwxface.c
@@ -313,9 +313,9 @@ acpi_status acpi_get_register(u32 regist
 	acpi_status status;
 	acpi_cpu_flags flags;
 
-	flags = acpi_os_acquire_lock(acpi_gbl_hardware_lock);
+	spin_lock_irqsave(acpi_gbl_hardware_lock, flags);
 	status = acpi_get_register_unlocked(register_id, return_value);
-	acpi_os_release_lock(acpi_gbl_hardware_lock, flags);
+	spin_unlock_irqrestore(acpi_gbl_hardware_lock, flags);
 
 	return (status);
 }
@@ -353,7 +353,7 @@ acpi_status acpi_set_register(u32 regist
 		return_ACPI_STATUS(AE_BAD_PARAMETER);
 	}
 
-	lock_flags = acpi_os_acquire_lock(acpi_gbl_hardware_lock);
+	spin_lock_irqsave(acpi_gbl_hardware_lock, lock_flags);
 
 	/* Always do a register read first so we can insert the new bits  */
 
@@ -458,7 +458,7 @@ acpi_status acpi_set_register(u32 regist
 
       unlock_and_exit:
 
-	acpi_os_release_lock(acpi_gbl_hardware_lock, lock_flags);
+	spin_unlock_irqrestore(acpi_gbl_hardware_lock, lock_flags);
 
 	/* Normalize the value that was read */
 
Index: linux-2.6-tip/drivers/acpi/acpica/utmutex.c
===================================================================
--- linux-2.6-tip.orig/drivers/acpi/acpica/utmutex.c
+++ linux-2.6-tip/drivers/acpi/acpica/utmutex.c
@@ -117,7 +117,7 @@ void acpi_ut_mutex_terminate(void)
 	/* Delete the spinlocks */
 
 	acpi_os_delete_lock(acpi_gbl_gpe_lock);
-	acpi_os_delete_lock(acpi_gbl_hardware_lock);
+//	acpi_os_delete_lock(acpi_gbl_hardware_lock);
 	return_VOID;
 }
 
Index: linux-2.6-tip/drivers/acpi/ec.c
===================================================================
--- linux-2.6-tip.orig/drivers/acpi/ec.c
+++ linux-2.6-tip/drivers/acpi/ec.c
@@ -563,8 +563,21 @@ static u32 acpi_ec_gpe_handler(void *dat
 	if (test_bit(EC_FLAGS_GPE_MODE, &ec->flags)) {
 		gpe_transaction(ec, status);
 		if (ec_transaction_done(ec) &&
-		    (status & ACPI_EC_FLAG_IBF) == 0)
+		    (status & ACPI_EC_FLAG_IBF) == 0) {
+#if 0
 			wake_up(&ec->wait);
+#else
+			// hack ...
+			if (waitqueue_active(&ec->wait)) {
+				struct task_struct *task;
+
+				task = list_entry(ec->wait.task_list.next,
+					  wait_queue_t, task_list)->private;
+				if (task)
+					wake_up_process(task);
+			}
+#endif
+		}
 	}
 
 	ec_check_sci(ec, status);
Index: linux-2.6-tip/drivers/acpi/processor_idle.c
===================================================================
--- linux-2.6-tip.orig/drivers/acpi/processor_idle.c
+++ linux-2.6-tip/drivers/acpi/processor_idle.c
@@ -956,7 +956,7 @@ static int acpi_idle_enter_simple(struct
 }
 
 static int c3_cpu_count;
-static DEFINE_SPINLOCK(c3_lock);
+static DEFINE_RAW_SPINLOCK(c3_lock);
 
 /**
  * acpi_idle_enter_bm - enters C3 with proper BM handling
Index: linux-2.6-tip/include/acpi/acpiosxf.h
===================================================================
--- linux-2.6-tip.orig/include/acpi/acpiosxf.h
+++ linux-2.6-tip/include/acpi/acpiosxf.h
@@ -61,7 +61,7 @@ typedef enum {
 	OSL_EC_BURST_HANDLER
 } acpi_execute_type;
 
-#define ACPI_NO_UNIT_LIMIT          ((u32) -1)
+#define ACPI_NO_UNIT_LIMIT          (INT_MAX/2)
 #define ACPI_MUTEX_SEM              1
 
 /* Functions for acpi_os_signal */
