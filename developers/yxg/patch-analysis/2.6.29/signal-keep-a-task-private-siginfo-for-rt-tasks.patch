Subject: signals: allow rt tasks to cache one sigqueue struct
From: Thomas Gleixner <tglx@linutronix.de>
Date: Wed, 18 Mar 2009 21:28:08 +0100


Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
---
 include/linux/sched.h  |    1 
 include/linux/signal.h |    1 
 kernel/exit.c          |    2 -
 kernel/signal.c        |   74 +++++++++++++++++++++++++++++++++++++++++++++----
 4 files changed, 71 insertions(+), 7 deletions(-)

Index: linux-2.6-tip/include/linux/sched.h
===================================================================
--- linux-2.6-tip.orig/include/linux/sched.h
+++ linux-2.6-tip/include/linux/sched.h
@@ -1341,6 +1341,7 @@ struct task_struct {
 /* signal handlers */
 	struct signal_struct *signal;
 	struct sighand_struct *sighand;
+	struct sigqueue *sigqueue_cache;
 
 	sigset_t blocked, real_blocked;
 	sigset_t saved_sigmask;	/* restored if set_restore_sigmask() was used */
Index: linux-2.6-tip/include/linux/signal.h
===================================================================
--- linux-2.6-tip.orig/include/linux/signal.h
+++ linux-2.6-tip/include/linux/signal.h
@@ -225,6 +225,7 @@ static inline void init_sigpending(struc
 }
 
 extern void flush_sigqueue(struct sigpending *queue);
+extern void flush_task_sigqueue(struct task_struct *tsk);
 
 /* Test if 'sig' is valid signal. Use this instead of testing _NSIG directly */
 static inline int valid_signal(unsigned long sig)
Index: linux-2.6-tip/kernel/exit.c
===================================================================
--- linux-2.6-tip.orig/kernel/exit.c
+++ linux-2.6-tip/kernel/exit.c
@@ -140,7 +140,7 @@ static void __exit_signal(struct task_st
 	 * Do this under ->siglock, we can race with another thread
 	 * doing sigqueue_free() if we have SIGQUEUE_PREALLOC signals.
 	 */
-	flush_sigqueue(&tsk->pending);
+	flush_task_sigqueue(tsk);
 
 	tsk->signal = NULL;
 	tsk->sighand = NULL;
Index: linux-2.6-tip/kernel/signal.c
===================================================================
--- linux-2.6-tip.orig/kernel/signal.c
+++ linux-2.6-tip/kernel/signal.c
@@ -179,13 +179,28 @@ int next_signal(struct sigpending *pendi
 	return sig;
 }
 
+static struct sigqueue *sigqueue_alloc_from_task_cache(struct task_struct *t,
+						       int fromslab)
+{
+	struct sigqueue *q = NULL;
+
+	if (!fromslab) {
+#ifdef __HAVE_ARCH_CMPXCHG
+		q = t->sigqueue_cache;
+		if (cmpxchg(&t->sigqueue_cache, q, NULL) != q)
+			q = NULL;
+#endif
+	}
+	return q;
+}
+
 /*
  * allocate a new signal queue record
  * - this may be called without locks if and only if t == current, otherwise an
  *   appopriate lock must be held to stop the target task from exiting
  */
-static struct sigqueue *__sigqueue_alloc(struct task_struct *t, gfp_t flags,
-					 int override_rlimit)
+static struct sigqueue *__sigqueue_do_alloc(struct task_struct *t, gfp_t flags,
+					    int override_rlimit, int fromslab)
 {
 	struct sigqueue *q = NULL;
 	struct user_struct *user;
@@ -200,8 +215,13 @@ static struct sigqueue *__sigqueue_alloc
 	atomic_inc(&user->sigpending);
 	if (override_rlimit ||
 	    atomic_read(&user->sigpending) <=
-			t->signal->rlim[RLIMIT_SIGPENDING].rlim_cur)
-		q = kmem_cache_alloc(sigqueue_cachep, flags);
+	    t->signal->rlim[RLIMIT_SIGPENDING].rlim_cur) {
+
+		q = sigqueue_alloc_from_task_cache(t, fromslab);
+		if (!q)
+			q = kmem_cache_alloc(sigqueue_cachep, flags);
+	}
+
 	if (unlikely(q == NULL)) {
 		atomic_dec(&user->sigpending);
 		free_uid(user);
@@ -214,6 +234,12 @@ static struct sigqueue *__sigqueue_alloc
 	return q;
 }
 
+static struct sigqueue *__sigqueue_alloc(struct task_struct *t, gfp_t flags,
+					 int override_rlimit)
+{
+	return __sigqueue_do_alloc(t, flags, override_rlimit, 0);
+}
+
 static void __sigqueue_free(struct sigqueue *q)
 {
 	if (q->flags & SIGQUEUE_PREALLOC)
@@ -223,6 +249,22 @@ static void __sigqueue_free(struct sigqu
 	kmem_cache_free(sigqueue_cachep, q);
 }
 
+static void sigqueue_free_current(struct sigqueue *q)
+{
+	if (q->flags & SIGQUEUE_PREALLOC)
+		return;
+
+#ifdef __HAVE_ARCH_CMPXCHG
+	if (rt_prio(current->normal_prio) &&
+	    cmpxchg(&current->sigqueue_cache, NULL, q) == NULL) {
+		atomic_dec(&q->user->sigpending);
+		free_uid(q->user);
+		return;
+	}
+#endif
+	__sigqueue_free(q);
+}
+
 void flush_sigqueue(struct sigpending *queue)
 {
 	struct sigqueue *q;
@@ -236,6 +278,23 @@ void flush_sigqueue(struct sigpending *q
 }
 
 /*
+ * Called from __exit_signal. Flush tsk->pending and
+ * tsk->sigqueue_cache
+ */
+void flush_task_sigqueue(struct task_struct *tsk)
+{
+	struct sigqueue *q;
+
+	flush_sigqueue(&tsk->pending);
+
+	q = tsk->sigqueue_cache;
+	tsk->sigqueue_cache = NULL;
+
+	if (q)
+		kmem_cache_free(sigqueue_cachep, q);
+}
+
+/*
  * Flush all pending signals for a task.
  */
 void flush_signals(struct task_struct *t)
@@ -378,7 +437,7 @@ static void collect_signal(int sig, stru
 still_pending:
 		list_del_init(&first->list);
 		copy_siginfo(info, &first->info);
-		__sigqueue_free(first);
+		sigqueue_free_current(first);
 	} else {
 		/* Ok, it wasn't in the queue.  This must be
 		   a fast-pathed signal or we must have been
@@ -423,6 +482,8 @@ int dequeue_signal(struct task_struct *t
 {
 	int signr;
 
+	WARN_ON_ONCE(tsk != current);
+
 	/* We only dequeue private signals from ourselves, we don't let
 	 * signalfd steal them
 	 */
@@ -1278,7 +1339,8 @@ struct sigqueue *sigqueue_alloc(void)
 {
 	struct sigqueue *q;
 
-	if ((q = __sigqueue_alloc(current, GFP_KERNEL, 0)))
+	/* Preallocated sigqueue objects always from the slabcache ! */
+	if ((q = __sigqueue_do_alloc(current, GFP_KERNEL, 0, 1)))
 		q->flags |= SIGQUEUE_PREALLOC;
 	return(q);
 }
