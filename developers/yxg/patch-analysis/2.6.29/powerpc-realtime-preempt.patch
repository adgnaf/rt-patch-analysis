Subject: powerpc-realtime-preempt.patch
From: Thomas Gleixner <tglx@linutronix.de>
Date: Fri, 20 Mar 2009 17:35:01 +0100

Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
---
 arch/powerpc/Kconfig               |   15 +++++------
 arch/powerpc/kernel/entry_64.S     |   50 +++++++++++++++++++++----------------
 arch/powerpc/kernel/idle.c         |    6 ++--
 arch/powerpc/platforms/chrp/time.c |    5 +++
 arch/powerpc/xmon/xmon.c           |    2 +
 5 files changed, 48 insertions(+), 30 deletions(-)

Index: linux-2.6-tip/arch/powerpc/Kconfig
===================================================================
--- linux-2.6-tip.orig/arch/powerpc/Kconfig
+++ linux-2.6-tip/arch/powerpc/Kconfig
@@ -65,13 +65,6 @@ config LOCKDEP_SUPPORT
 	bool
 	default y
 
-config RWSEM_GENERIC_SPINLOCK
-	bool
-
-config RWSEM_XCHGADD_ALGORITHM
-	bool
-	default y
-
 config GENERIC_LOCKBREAK
 	bool
 	default y
@@ -243,6 +236,14 @@ config HIGHMEM
 source kernel/time/Kconfig
 source kernel/Kconfig.hz
 source kernel/Kconfig.preempt
+
+config RWSEM_GENERIC_SPINLOCK
+	bool
+	default y
+
+config RWSEM_XCHGADD_ALGORITHM
+	bool
+
 source "fs/Kconfig.binfmt"
 
 config HUGETLB_PAGE_SIZE_VARIABLE
Index: linux-2.6-tip/arch/powerpc/kernel/entry_64.S
===================================================================
--- linux-2.6-tip.orig/arch/powerpc/kernel/entry_64.S
+++ linux-2.6-tip/arch/powerpc/kernel/entry_64.S
@@ -625,44 +625,52 @@ do_work:
 	bne	restore
 	/* here we are preempting the current task */
 1:
+	/*
+	 * preempt_schedule_irq() expects interrupts disabled and returns
+	 * with interrupts disabled. No need to check preemption again,
+	 * preempt_schedule_irq just did that for us.
+	 */
+	bl	.preempt_schedule_irq
 #ifdef CONFIG_TRACE_IRQFLAGS
 	bl	.trace_hardirqs_on
+#endif /* CONFIG_TRACE_IRQFLAGS */
+
 	/* Note: we just clobbered r10 which used to contain the previous
 	 * MSR before the hard-disabling done by the caller of do_work.
 	 * We don't have that value anymore, but it doesn't matter as
 	 * we will hard-enable unconditionally, we can just reload the
 	 * current MSR into r10
 	 */
+	bl		.preempt_schedule_irq
 	mfmsr	r10
-#endif /* CONFIG_TRACE_IRQFLAGS */
-	li	r0,1
-	stb	r0,PACASOFTIRQEN(r13)
-	stb	r0,PACAHARDIRQEN(r13)
-	ori	r10,r10,MSR_EE
-	mtmsrd	r10,1		/* reenable interrupts */
-	bl	.preempt_schedule
-	mfmsr	r10
-	clrrdi	r9,r1,THREAD_SHIFT
-	rldicl	r10,r10,48,1	/* disable interrupts again */
-	rotldi	r10,r10,16
-	mtmsrd	r10,1
-	ld	r4,TI_FLAGS(r9)
-	andi.	r0,r4,_TIF_NEED_RESCHED
-	bne	1b
+	clrrdi  r9,r1,THREAD_SHIFT
+	rldicl  r10,r10,48,1    /* disable interrupts again */
+	rotldi  r10,r10,16
+	mtmsrd  r10,1
+	ld      r4,TI_FLAGS(r9)
+	andi.   r0,r4,(_TIF_NEED_RESCHED)
+	bne     1b
 	b	restore
 
 user_work:
 #endif
-	/* Enable interrupts */
-	ori	r10,r10,MSR_EE
-	mtmsrd	r10,1
-
 	andi.	r0,r4,_TIF_NEED_RESCHED
 	beq	1f
-	bl	.schedule
+
+	/* preempt_schedule_irq() expects interrupts disabled. */
+	bl	.preempt_schedule_irq
 	b	.ret_from_except_lite
 
-1:	bl	.save_nvgprs
+	/* here we are preempting the current task */
+1:	li	r0,1
+	stb	r0,PACASOFTIRQEN(r13)
+	stb	r0,PACAHARDIRQEN(r13)
+
+	/* Enable interrupts */
+	ori	r10,r10,MSR_EE
+	mtmsrd	r10,1
+
+	bl	.save_nvgprs
 	addi	r3,r1,STACK_FRAME_OVERHEAD
 	bl	.do_signal
 	b	.ret_from_except
Index: linux-2.6-tip/arch/powerpc/kernel/idle.c
===================================================================
--- linux-2.6-tip.orig/arch/powerpc/kernel/idle.c
+++ linux-2.6-tip/arch/powerpc/kernel/idle.c
@@ -96,9 +96,11 @@ void cpu_idle(void)
 		tick_nohz_restart_sched_tick();
 		if (cpu_should_die())
 			cpu_die();
-		preempt_enable_no_resched();
-		schedule();
+		local_irq_disable();
+		__preempt_enable_no_resched();
+		__schedule();
 		preempt_disable();
+		local_irq_enable();
 	}
 }
 
Index: linux-2.6-tip/arch/powerpc/platforms/chrp/time.c
===================================================================
--- linux-2.6-tip.orig/arch/powerpc/platforms/chrp/time.c
+++ linux-2.6-tip/arch/powerpc/platforms/chrp/time.c
@@ -83,7 +83,12 @@ int chrp_set_rtc_time(struct rtc_time *t
 	unsigned char save_control, save_freq_select;
 	struct rtc_time tm = *tmarg;
 
+#if CONFIG_PREEMPT_RT
+	if (!spin_trylock(&rtc_lock))
+		return -1;
+#else
 	spin_lock(&rtc_lock);
+#endif
 
 	save_control = chrp_cmos_clock_read(RTC_CONTROL); /* tell the clock it's being set */
 
Index: linux-2.6-tip/arch/powerpc/xmon/xmon.c
===================================================================
--- linux-2.6-tip.orig/arch/powerpc/xmon/xmon.c
+++ linux-2.6-tip/arch/powerpc/xmon/xmon.c
@@ -346,6 +346,7 @@ static int xmon_core(struct pt_regs *reg
 	unsigned long timeout;
 #endif
 
+	preempt_disable();
 	local_irq_save(flags);
 
 	bp = in_breakpoint_table(regs->nip, &offset);
@@ -522,6 +523,7 @@ static int xmon_core(struct pt_regs *reg
 	insert_cpu_bpts();
 
 	local_irq_restore(flags);
+	preempt_enable();
 
 	return cmd != 'X' && cmd != EOF;
 }
