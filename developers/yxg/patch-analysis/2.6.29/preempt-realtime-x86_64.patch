Subject: patches/preempt-realtime-x86_64.patch


Signed-off-by: Ingo Molnar <mingo@elte.hu>
---
 arch/x86/include/asm/acpi.h     |    4 ++--
 arch/x86/include/asm/i8259.h    |    2 +-
 arch/x86/include/asm/spinlock.h |    6 +++---
 arch/x86/include/asm/tlbflush.h |    2 ++
 arch/x86/include/asm/vgtod.h    |    2 +-
 arch/x86/kernel/apic/io_apic.c  |    4 ++--
 arch/x86/kernel/apic/nmi.c      |    2 ++
 arch/x86/kernel/early_printk.c  |    2 +-
 arch/x86/kernel/head64.c        |    6 +++++-
 arch/x86/kernel/i8259.c         |    2 +-
 arch/x86/kernel/process_64.c    |    6 ++++--
 arch/x86/kernel/signal.c        |    7 +++++++
 arch/x86/kernel/smp.c           |   10 ++++++++++
 arch/x86/mm/tlb.c               |    2 +-
 14 files changed, 42 insertions(+), 15 deletions(-)

Index: linux-2.6-tip/arch/x86/include/asm/acpi.h
===================================================================
--- linux-2.6-tip.orig/arch/x86/include/asm/acpi.h
+++ linux-2.6-tip/arch/x86/include/asm/acpi.h
@@ -50,8 +50,8 @@
 
 #define ACPI_ASM_MACROS
 #define BREAKPOINT3
-#define ACPI_DISABLE_IRQS() local_irq_disable()
-#define ACPI_ENABLE_IRQS()  local_irq_enable()
+#define ACPI_DISABLE_IRQS() local_irq_disable_nort()
+#define ACPI_ENABLE_IRQS()  local_irq_enable_nort()
 #define ACPI_FLUSH_CPU_CACHE()	wbinvd()
 
 int __acpi_acquire_global_lock(unsigned int *lock);
Index: linux-2.6-tip/arch/x86/include/asm/i8259.h
===================================================================
--- linux-2.6-tip.orig/arch/x86/include/asm/i8259.h
+++ linux-2.6-tip/arch/x86/include/asm/i8259.h
@@ -24,7 +24,7 @@ extern unsigned int cached_irq_mask;
 #define SLAVE_ICW4_DEFAULT	0x01
 #define PIC_ICW4_AEOI		2
 
-extern spinlock_t i8259A_lock;
+extern raw_spinlock_t i8259A_lock;
 
 extern void init_8259A(int auto_eoi);
 extern void enable_8259A_irq(unsigned int irq);
Index: linux-2.6-tip/arch/x86/include/asm/spinlock.h
===================================================================
--- linux-2.6-tip.orig/arch/x86/include/asm/spinlock.h
+++ linux-2.6-tip/arch/x86/include/asm/spinlock.h
@@ -295,8 +295,8 @@ static inline void __raw_write_unlock(__
 		     : "+m" (rw->lock) : "i" (RW_LOCK_BIAS) : "memory");
 }
 
-#define _raw_spin_relax(lock)	cpu_relax()
-#define _raw_read_relax(lock)	cpu_relax()
-#define _raw_write_relax(lock)	cpu_relax()
+#define __raw_spin_relax(lock)	cpu_relax()
+#define __raw_read_relax(lock)	cpu_relax()
+#define __raw_write_relax(lock)	cpu_relax()
 
 #endif /* _ASM_X86_SPINLOCK_H */
Index: linux-2.6-tip/arch/x86/include/asm/tlbflush.h
===================================================================
--- linux-2.6-tip.orig/arch/x86/include/asm/tlbflush.h
+++ linux-2.6-tip/arch/x86/include/asm/tlbflush.h
@@ -17,7 +17,9 @@
 
 static inline void __native_flush_tlb(void)
 {
+	preempt_disable();
 	write_cr3(read_cr3());
+	preempt_enable();
 }
 
 static inline void __native_flush_tlb_global(void)
Index: linux-2.6-tip/arch/x86/include/asm/vgtod.h
===================================================================
--- linux-2.6-tip.orig/arch/x86/include/asm/vgtod.h
+++ linux-2.6-tip/arch/x86/include/asm/vgtod.h
@@ -5,7 +5,7 @@
 #include <linux/clocksource.h>
 
 struct vsyscall_gtod_data {
-	seqlock_t	lock;
+	raw_seqlock_t	lock;
 
 	/* open coded 'struct timespec' */
 	time_t		wall_time_sec;
Index: linux-2.6-tip/arch/x86/kernel/apic/io_apic.c
===================================================================
--- linux-2.6-tip.orig/arch/x86/kernel/apic/io_apic.c
+++ linux-2.6-tip/arch/x86/kernel/apic/io_apic.c
@@ -72,8 +72,8 @@
  */
 int sis_apic_bug = -1;
 
-static DEFINE_SPINLOCK(ioapic_lock);
-static DEFINE_SPINLOCK(vector_lock);
+static DEFINE_RAW_SPINLOCK(ioapic_lock);
+static DEFINE_RAW_SPINLOCK(vector_lock);
 
 /*
  * # of IRQ routing registers
Index: linux-2.6-tip/arch/x86/kernel/apic/nmi.c
===================================================================
--- linux-2.6-tip.orig/arch/x86/kernel/apic/nmi.c
+++ linux-2.6-tip/arch/x86/kernel/apic/nmi.c
@@ -90,7 +90,9 @@ static inline unsigned int get_timer_irq
  */
 static __init void nmi_cpu_busy(void *data)
 {
+#ifndef CONFIG_PREEMPT_RT
 	local_irq_enable_in_hardirq();
+#endif
 	/*
 	 * Intentionally don't use cpu_relax here. This is
 	 * to make sure that the performance counter really ticks,
Index: linux-2.6-tip/arch/x86/kernel/early_printk.c
===================================================================
--- linux-2.6-tip.orig/arch/x86/kernel/early_printk.c
+++ linux-2.6-tip/arch/x86/kernel/early_printk.c
@@ -881,7 +881,7 @@ static int __initdata early_console_init
 
 asmlinkage void early_printk(const char *fmt, ...)
 {
-	char buf[512];
+	static char buf[512];
 	int n;
 	va_list ap;
 
Index: linux-2.6-tip/arch/x86/kernel/head64.c
===================================================================
--- linux-2.6-tip.orig/arch/x86/kernel/head64.c
+++ linux-2.6-tip/arch/x86/kernel/head64.c
@@ -30,7 +30,11 @@ static void __init zap_identity_mappings
 {
 	pgd_t *pgd = pgd_offset_k(0UL);
 	pgd_clear(pgd);
-	__flush_tlb_all();
+	/*
+	 * preempt_disable/enable does not work this early in the
+	 * bootup yet:
+	 */
+	write_cr3(read_cr3());
 }
 
 /* Don't add a printk in there. printk relies on the PDA which is not initialized 
Index: linux-2.6-tip/arch/x86/kernel/i8259.c
===================================================================
--- linux-2.6-tip.orig/arch/x86/kernel/i8259.c
+++ linux-2.6-tip/arch/x86/kernel/i8259.c
@@ -32,8 +32,8 @@
  */
 
 static int i8259A_auto_eoi;
-DEFINE_SPINLOCK(i8259A_lock);
 static void mask_and_ack_8259A(unsigned int);
+DEFINE_RAW_SPINLOCK(i8259A_lock);
 
 struct irq_chip i8259A_chip = {
 	.name		= "XT-PIC",
Index: linux-2.6-tip/arch/x86/kernel/process_64.c
===================================================================
--- linux-2.6-tip.orig/arch/x86/kernel/process_64.c
+++ linux-2.6-tip/arch/x86/kernel/process_64.c
@@ -155,9 +155,11 @@ void cpu_idle(void)
 		}
 
 		tick_nohz_restart_sched_tick();
-		preempt_enable_no_resched();
-		schedule();
+		local_irq_disable();
+		__preempt_enable_no_resched();
+		__schedule();
 		preempt_disable();
+		local_irq_enable();
 	}
 }
 
Index: linux-2.6-tip/arch/x86/kernel/signal.c
===================================================================
--- linux-2.6-tip.orig/arch/x86/kernel/signal.c
+++ linux-2.6-tip/arch/x86/kernel/signal.c
@@ -783,6 +783,13 @@ static void do_signal(struct pt_regs *re
 	int signr;
 	sigset_t *oldset;
 
+#ifdef CONFIG_PREEMPT_RT
+	/*
+	 * Fully-preemptible kernel does not need interrupts disabled:
+	 */
+	local_irq_enable();
+	preempt_check_resched();
+#endif
 	/*
 	 * We want the common case to go fast, which is why we may in certain
 	 * cases get here from kernel mode. Just return without doing anything
Index: linux-2.6-tip/arch/x86/kernel/smp.c
===================================================================
--- linux-2.6-tip.orig/arch/x86/kernel/smp.c
+++ linux-2.6-tip/arch/x86/kernel/smp.c
@@ -120,6 +120,16 @@ static void native_smp_send_reschedule(i
 	apic->send_IPI_mask(cpumask_of(cpu), RESCHEDULE_VECTOR);
 }
 
+/*
+ * this function sends a 'reschedule' IPI to all other CPUs.
+ * This is used when RT tasks are starving and other CPUs
+ * might be able to run them:
+ */
+void smp_send_reschedule_allbutself(void)
+{
+	apic->send_IPI_allbutself(RESCHEDULE_VECTOR);
+}
+
 void native_send_call_func_single_ipi(int cpu)
 {
 	apic->send_IPI_mask(cpumask_of(cpu), CALL_FUNCTION_SINGLE_VECTOR);
Index: linux-2.6-tip/arch/x86/mm/tlb.c
===================================================================
--- linux-2.6-tip.orig/arch/x86/mm/tlb.c
+++ linux-2.6-tip/arch/x86/mm/tlb.c
@@ -40,8 +40,8 @@ union smp_flush_state {
 	struct {
 		struct mm_struct *flush_mm;
 		unsigned long flush_va;
-		spinlock_t tlbstate_lock;
 		DECLARE_BITMAP(flush_cpumask, NR_CPUS);
+		raw_spinlock_t tlbstate_lock;
 	};
 	char pad[CONFIG_X86_INTERNODE_CACHE_BYTES];
 } ____cacheline_internodealigned_in_smp;
