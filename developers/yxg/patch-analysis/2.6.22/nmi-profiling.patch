---
 arch/i386/kernel/irq.c    |    2 ++
 arch/i386/kernel/nmi.c    |    7 +++----
 arch/x86_64/kernel/nmi.c  |    6 +++---
 drivers/char/sysrq.c      |    2 +-
 include/asm-x86_64/apic.h |    2 ++
 5 files changed, 11 insertions(+), 8 deletions(-)

Index: linux-rt.q/arch/i386/kernel/irq.c
===================================================================
--- linux-rt.q.orig/arch/i386/kernel/irq.c
+++ linux-rt.q/arch/i386/kernel/irq.c
@@ -79,7 +79,9 @@ fastcall notrace unsigned int do_IRQ(str
 	u32 *isp;
 #endif
 
+#ifdef CONFIG_X86_LOCAL_APIC
 	irq_show_regs_callback(smp_processor_id(), regs);
+#endif
 
 	if (unlikely((unsigned)irq >= NR_IRQS)) {
 		printk(KERN_EMERG "%s: cannot handle IRQ %d\n",
Index: linux-rt.q/arch/i386/kernel/nmi.c
===================================================================
--- linux-rt.q.orig/arch/i386/kernel/nmi.c
+++ linux-rt.q/arch/i386/kernel/nmi.c
@@ -348,9 +348,9 @@ void nmi_show_all_regs(void)
 	}
 }
 
-static DEFINE_SPINLOCK(nmi_print_lock);
+static DEFINE_RAW_SPINLOCK(nmi_print_lock);
 
-void irq_show_regs_callback(int cpu, struct pt_regs *regs)
+notrace void irq_show_regs_callback(int cpu, struct pt_regs *regs)
 {
 	if (!nmi_show_regs[cpu])
 		return;
@@ -364,7 +364,7 @@ void irq_show_regs_callback(int cpu, str
 	spin_unlock(&nmi_print_lock);
 }
 
-__kprobes int nmi_watchdog_tick(struct pt_regs *regs, unsigned reason)
+notrace __kprobes int nmi_watchdog_tick(struct pt_regs *regs, unsigned reason)
 {
 	/*
 	 * Since current_thread_info()-> is always on the stack, and we
@@ -432,7 +432,6 @@ __kprobes int nmi_watchdog_tick(struct p
 			for_each_online_cpu(i)
 				alert_counter[i] = 0;
 
-
 		}
 
 	} else {
Index: linux-rt.q/arch/x86_64/kernel/nmi.c
===================================================================
--- linux-rt.q.orig/arch/x86_64/kernel/nmi.c
+++ linux-rt.q/arch/x86_64/kernel/nmi.c
@@ -337,9 +337,9 @@ void nmi_show_all_regs(void)
 	}
 }
 
-static DEFINE_SPINLOCK(nmi_print_lock);
+static DEFINE_RAW_SPINLOCK(nmi_print_lock);
 
-void irq_show_regs_callback(int cpu, struct pt_regs *regs)
+notrace void irq_show_regs_callback(int cpu, struct pt_regs *regs)
 {
 	if (!nmi_show_regs[cpu])
 		return;
@@ -352,7 +352,7 @@ void irq_show_regs_callback(int cpu, str
 	spin_unlock(&nmi_print_lock);
 }
 
-int __kprobes nmi_watchdog_tick(struct pt_regs * regs, unsigned reason)
+int notrace __kprobes nmi_watchdog_tick(struct pt_regs * regs, unsigned reason)
 {
 	int sum;
 	int touched = 0;
Index: linux-rt.q/drivers/char/sysrq.c
===================================================================
--- linux-rt.q.orig/drivers/char/sysrq.c
+++ linux-rt.q/drivers/char/sysrq.c
@@ -208,7 +208,7 @@ static struct sysrq_key_op sysrq_showreg
 	.enable_mask	= SYSRQ_ENABLE_DUMP,
 };
 
-#if defined(__i386__)
+#if defined(__i386__) || defined(__x86_64__)
 
 static void sysrq_handle_showallregs(int key, struct tty_struct *tty)
 {
Index: linux-rt.q/include/asm-x86_64/apic.h
===================================================================
--- linux-rt.q.orig/include/asm-x86_64/apic.h
+++ linux-rt.q/include/asm-x86_64/apic.h
@@ -95,6 +95,8 @@ extern void smp_send_nmi_allbutself(void
 #define K8_APIC_EXT_INT_MSG_EXT 0x7
 #define K8_APIC_EXT_LVT_ENTRY_THRESHOLD    0
 
+extern void smp_send_nmi_allbutself(void);
+
 #define ARCH_APICTIMER_STOPS_ON_C3	1
 
 extern unsigned boot_cpu_id;
