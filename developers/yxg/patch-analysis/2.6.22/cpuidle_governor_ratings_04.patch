

Introduce a governor rating scheme to pick the right governor by default.

Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>

---
 drivers/cpuidle/governor.c         |   33 ++++++++++++++++++++++++++++++---
 drivers/cpuidle/governors/ladder.c |    1 +
 drivers/cpuidle/governors/menu.c   |    1 +
 include/linux/cpuidle.h            |    1 +
 4 files changed, 33 insertions(+), 3 deletions(-)

Index: linux-rt.q/drivers/cpuidle/governor.c
===================================================================
--- linux-rt.q.orig/drivers/cpuidle/governor.c
+++ linux-rt.q/drivers/cpuidle/governor.c
@@ -131,7 +131,8 @@ int cpuidle_register_governor(struct cpu
 	if (__cpuidle_find_governor(gov->name) == NULL) {
 		ret = 0;
 		list_add_tail(&gov->governor_list, &cpuidle_governors);
-		if (!cpuidle_curr_governor)
+		if (!cpuidle_curr_governor ||
+		    cpuidle_curr_governor->rating < gov->rating)
 			cpuidle_switch_governor(gov);
 	}
 	mutex_unlock(&cpuidle_lock);
@@ -142,6 +143,29 @@ int cpuidle_register_governor(struct cpu
 EXPORT_SYMBOL_GPL(cpuidle_register_governor);
 
 /**
+ * cpuidle_replace_governor - find a replacement governor
+ * @exclude_rating: the rating that will be skipped while looking for
+ * new governor.
+ */
+struct cpuidle_governor *cpuidle_replace_governor(int exclude_rating)
+{
+	struct cpuidle_governor *gov;
+	struct cpuidle_governor *ret_gov = NULL;
+	unsigned int max_rating = 0;
+
+	list_for_each_entry(gov, &cpuidle_governors, governor_list) {
+		if (gov->rating == exclude_rating)
+			continue;
+		if (gov->rating > max_rating) {
+			max_rating = gov->rating;
+			ret_gov = gov;
+		}
+	}
+
+	return ret_gov;
+}
+
+/**
  * cpuidle_unregister_governor - unregisters a governor
  * @gov: the governor
  */
@@ -151,8 +175,11 @@ void cpuidle_unregister_governor(struct 
 		return;
 
 	mutex_lock(&cpuidle_lock);
-	if (gov == cpuidle_curr_governor)
-		cpuidle_switch_governor(NULL);
+	if (gov == cpuidle_curr_governor) {
+		struct cpuidle_governor *new_gov;
+		new_gov = cpuidle_replace_governor(gov->rating);
+		cpuidle_switch_governor(new_gov);
+	}
 	list_del(&gov->governor_list);
 	mutex_unlock(&cpuidle_lock);
 }
Index: linux-rt.q/drivers/cpuidle/governors/ladder.c
===================================================================
--- linux-rt.q.orig/drivers/cpuidle/governors/ladder.c
+++ linux-rt.q/drivers/cpuidle/governors/ladder.c
@@ -199,6 +199,7 @@ static void ladder_exit_device(struct cp
 
 static struct cpuidle_governor ladder_governor = {
 	.name =		"ladder",
+	.rating =	10,
 	.init =		ladder_init_device,
 	.exit =		ladder_exit_device,
 	.scan =		ladder_scan_device,
Index: linux-rt.q/drivers/cpuidle/governors/menu.c
===================================================================
--- linux-rt.q.orig/drivers/cpuidle/governors/menu.c
+++ linux-rt.q/drivers/cpuidle/governors/menu.c
@@ -153,6 +153,7 @@ static void menu_scan_device(struct cpui
 
 struct cpuidle_governor menu_governor = {
 	.name =		"menu",
+	.rating =	20,
 	.scan =		menu_scan_device,
 	.select =	menu_select,
 	.reflect =	menu_reflect,
Index: linux-rt.q/include/linux/cpuidle.h
===================================================================
--- linux-rt.q.orig/include/linux/cpuidle.h
+++ linux-rt.q/include/linux/cpuidle.h
@@ -159,6 +159,7 @@ static inline int cpuidle_force_redetect
 struct cpuidle_governor {
 	char			name[CPUIDLE_NAME_LEN];
 	struct list_head 	governor_list;
+	unsigned int		rating;
 
 	int  (*init)		(struct cpuidle_device *dev);
 	void (*exit)		(struct cpuidle_device *dev);
