From: Thomas Gleixner <tglx@linutronix.de>

The cpuidle patches moved the tick nohz handling from irq_exit into the inner
idle loop.  The change is correct as it covers non interrupt based wakeups
(e.g DMA) on x86 as well, but the move breaks ARM, SH and SPARC64.

Keep the original implementation and deselet the irq exit code for those
architectures which have idle wakeups without interrupts.

This way the non affected architectures are not burdened with the extra
changes in the idle implementation.

Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Cc: Adam Belay <abelay@novell.com>
Cc: Len Brown <lenb@kernel.org>
Cc: Dave Miller <davem@davemloft.net>
Cc: Paul Mundt <lethal@linux-sh.org>
Cc: Russell King <rmk+kernel@arm.linux.org.uk>
Cc: Ingo Molnar <mingo@elte.hu>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
---

 arch/i386/Kconfig |    4 ++++
 kernel/softirq.c  |    5 +++++
 2 files changed, 9 insertions(+)

Index: linux-rt.q/arch/i386/Kconfig
===================================================================
--- linux-rt.q.orig/arch/i386/Kconfig
+++ linux-rt.q/arch/i386/Kconfig
@@ -31,6 +31,10 @@ config GENERIC_CLOCKEVENTS_BROADCAST
 	default y
 	depends on X86_LOCAL_APIC
 
+config NONIRQ_WAKEUP
+	bool
+	default y
+
 config LOCKDEP_SUPPORT
 	bool
 	default y
Index: linux-rt.q/kernel/softirq.c
===================================================================
--- linux-rt.q.orig/kernel/softirq.c
+++ linux-rt.q/kernel/softirq.c
@@ -303,6 +303,11 @@ void irq_exit(void)
 	if (!in_interrupt() && local_softirq_pending())
 		invoke_softirq();
 
+#if defined(CONFIG_NO_HZ) && !defined(CONFIG_NONIRQ_WAKEUP)
+	/* Make sure that timer wheel updates are propagated */
+	if (!in_interrupt() && idle_cpu(smp_processor_id()) && !need_resched())
+		tick_nohz_stop_sched_tick();
+#endif
 	preempt_enable_no_resched();
 }
 
