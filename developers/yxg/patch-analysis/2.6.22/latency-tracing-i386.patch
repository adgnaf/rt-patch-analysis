 arch/i386/Kconfig                  |    1 +
 arch/i386/boot/compressed/Makefile |    1 +
 arch/i386/kernel/Makefile          |    1 +
 arch/i386/kernel/apic.c            |    2 ++
 arch/i386/kernel/entry.S           |   15 +++++++++++++++
 arch/i386/kernel/hpet.c            |    2 +-
 arch/i386/kernel/irq.c             |    7 ++++++-
 arch/i386/kernel/mcount-wrapper.S  |   27 +++++++++++++++++++++++++++
 arch/i386/kernel/traps.c           |    1 +
 arch/i386/kernel/tsc.c             |    2 +-
 arch/i386/mm/fault.c               |    1 +
 arch/i386/mm/init.c                |    2 +-
 include/asm-i386/processor.h       |   11 +++++++----
 13 files changed, 65 insertions(+), 8 deletions(-)

Index: linux-rt.q/arch/i386/Kconfig
===================================================================
--- linux-rt.q.orig/arch/i386/Kconfig
+++ linux-rt.q/arch/i386/Kconfig
@@ -777,6 +777,7 @@ config BOOT_IOREMAP
 #
 config REGPARM
 	bool
+	depends on !MCOUNT
 	default y
 
 config SECCOMP
Index: linux-rt.q/arch/i386/boot/compressed/Makefile
===================================================================
--- linux-rt.q.orig/arch/i386/boot/compressed/Makefile
+++ linux-rt.q/arch/i386/boot/compressed/Makefile
@@ -9,6 +9,7 @@ targets		:= vmlinux vmlinux.bin vmlinux.
 EXTRA_AFLAGS	:= -traditional
 
 LDFLAGS_vmlinux := -T
+CFLAGS := -m32 -D__KERNEL__ -Iinclude -O2  -fno-strict-aliasing
 CFLAGS_misc.o += -fPIC
 hostprogs-y	:= relocs
 
Index: linux-rt.q/arch/i386/kernel/Makefile
===================================================================
--- linux-rt.q.orig/arch/i386/kernel/Makefile
+++ linux-rt.q/arch/i386/kernel/Makefile
@@ -21,6 +21,7 @@ obj-$(CONFIG_APM)		+= apm.o
 obj-$(CONFIG_X86_SMP)		+= smp.o smpboot.o tsc_sync.o
 obj-$(CONFIG_SMP)		+= smpcommon.o
 obj-$(CONFIG_X86_TRAMPOLINE)	+= trampoline.o
+obj-$(CONFIG_MCOUNT)		+= mcount-wrapper.o
 obj-$(CONFIG_X86_MPPARSE)	+= mpparse.o
 obj-$(CONFIG_X86_LOCAL_APIC)	+= apic.o nmi.o
 obj-$(CONFIG_X86_IO_APIC)	+= io_apic.o
Index: linux-rt.q/arch/i386/kernel/apic.c
===================================================================
--- linux-rt.q.orig/arch/i386/kernel/apic.c
+++ linux-rt.q/arch/i386/kernel/apic.c
@@ -583,6 +583,8 @@ void fastcall smp_apic_timer_interrupt(s
 {
 	struct pt_regs *old_regs = set_irq_regs(regs);
 
+	trace_special(regs->eip, 1, 0);
+
 	/*
 	 * NOTE! We'd better ACK the irq immediately,
 	 * because timer handling can be slow.
Index: linux-rt.q/arch/i386/kernel/entry.S
===================================================================
--- linux-rt.q.orig/arch/i386/kernel/entry.S
+++ linux-rt.q/arch/i386/kernel/entry.S
@@ -329,6 +329,11 @@ sysenter_past_esp:
 	pushl %eax
 	CFI_ADJUST_CFA_OFFSET 4
 	SAVE_ALL
+#ifdef CONFIG_EVENT_TRACE
+	pushl %edx; pushl %ecx; pushl %ebx; pushl %eax
+	call sys_call
+	popl %eax; popl %ebx; popl %ecx; popl %edx
+#endif
 	GET_THREAD_INFO(%ebp)
 
 	/* Note, _TIF_SECCOMP is bit number 8, and so it needs testw and not testb */
@@ -343,6 +348,11 @@ sysenter_past_esp:
 	movl TI_flags(%ebp), %ecx
 	testw $_TIF_ALLWORK_MASK, %cx
 	jne syscall_exit_work
+#ifdef CONFIG_EVENT_TRACE
+	pushl %eax
+	call sys_ret
+	popl %eax
+#endif
 /* if something modifies registers it must also disable sysexit */
 	movl PT_EIP(%esp), %edx
 	movl PT_OLDESP(%esp), %ecx
@@ -366,6 +376,11 @@ ENTRY(system_call)
 	pushl %eax			# save orig_eax
 	CFI_ADJUST_CFA_OFFSET 4
 	SAVE_ALL
+#ifdef CONFIG_EVENT_TRACE
+	pushl %edx; pushl %ecx; pushl %ebx; pushl %eax
+	call sys_call
+	popl %eax; popl %ebx; popl %ecx; popl %edx
+#endif
 	GET_THREAD_INFO(%ebp)
 					# system call tracing in operation / emulation
 	/* Note, _TIF_SECCOMP is bit number 8, and so it needs testw and not testb */
Index: linux-rt.q/arch/i386/kernel/hpet.c
===================================================================
--- linux-rt.q.orig/arch/i386/kernel/hpet.c
+++ linux-rt.q/arch/i386/kernel/hpet.c
@@ -305,7 +305,7 @@ static int hpet_legacy_next_event(unsign
 /*
  * Clock source related code
  */
-static cycle_t read_hpet(void)
+static cycle_t notrace read_hpet(void)
 {
 	return (cycle_t)hpet_readl(HPET_COUNTER);
 }
Index: linux-rt.q/arch/i386/kernel/irq.c
===================================================================
--- linux-rt.q.orig/arch/i386/kernel/irq.c
+++ linux-rt.q/arch/i386/kernel/irq.c
@@ -68,7 +68,7 @@ static union irq_ctx *softirq_ctx[NR_CPU
  * SMP cross-CPU interrupts have their own specific
  * handlers).
  */
-fastcall unsigned int do_IRQ(struct pt_regs *regs)
+fastcall notrace unsigned int do_IRQ(struct pt_regs *regs)
 {	
 	struct pt_regs *old_regs;
 	/* high bit used in ret_from_ code */
@@ -87,6 +87,11 @@ fastcall unsigned int do_IRQ(struct pt_r
 
 	old_regs = set_irq_regs(regs);
 	irq_enter();
+#ifdef CONFIG_EVENT_TRACE
+	if (irq == trace_user_trigger_irq)
+		user_trace_start();
+#endif
+	trace_special(regs->eip, irq, 0);
 #ifdef CONFIG_DEBUG_STACKOVERFLOW
 	/* Debugging check for stack overflow: is there less than 1KB free? */
 	{
Index: linux-rt.q/arch/i386/kernel/mcount-wrapper.S
===================================================================
--- /dev/null
+++ linux-rt.q/arch/i386/kernel/mcount-wrapper.S
@@ -0,0 +1,27 @@
+/*
+ *  linux/arch/i386/mcount-wrapper.S
+ *
+ *  Copyright (C) 2004 Ingo Molnar
+ */
+
+.globl mcount
+mcount:
+
+	cmpl $0, mcount_enabled
+	jz out
+
+	push %ebp
+	mov %esp, %ebp
+	pushl %eax
+	pushl %ecx
+	pushl %edx
+
+	call __mcount
+
+	popl %edx
+	popl %ecx
+	popl %eax
+	popl %ebp
+out:
+	ret
+
Index: linux-rt.q/arch/i386/kernel/traps.c
===================================================================
--- linux-rt.q.orig/arch/i386/kernel/traps.c
+++ linux-rt.q/arch/i386/kernel/traps.c
@@ -222,6 +222,7 @@ show_trace_log_lvl(struct task_struct *t
 {
 	dump_trace(task, regs, stack, &print_trace_ops, log_lvl);
 	printk("%s =======================\n", log_lvl);
+	print_traces(task);
 }
 
 void show_trace(struct task_struct *task, struct pt_regs *regs,
Index: linux-rt.q/arch/i386/kernel/tsc.c
===================================================================
--- linux-rt.q.orig/arch/i386/kernel/tsc.c
+++ linux-rt.q/arch/i386/kernel/tsc.c
@@ -261,7 +261,7 @@ core_initcall(cpufreq_tsc);
 
 static unsigned long current_tsc_khz = 0;
 
-static cycle_t read_tsc(void)
+static notrace cycle_t read_tsc(void)
 {
 	cycle_t ret;
 
Index: linux-rt.q/arch/i386/mm/fault.c
===================================================================
--- linux-rt.q.orig/arch/i386/mm/fault.c
+++ linux-rt.q/arch/i386/mm/fault.c
@@ -488,6 +488,7 @@ bad_area_nosemaphore:
 		nr = (address - idt_descr.address) >> 3;
 
 		if (nr == 6) {
+		stop_trace();
 			do_invalid_op(regs, 0);
 			return;
 		}
Index: linux-rt.q/arch/i386/mm/init.c
===================================================================
--- linux-rt.q.orig/arch/i386/mm/init.c
+++ linux-rt.q/arch/i386/mm/init.c
@@ -193,7 +193,7 @@ static inline int page_kills_ppro(unsign
 	return 0;
 }
 
-int page_is_ram(unsigned long pagenr)
+int notrace page_is_ram(unsigned long pagenr)
 {
 	int i;
 	unsigned long addr, end;
Index: linux-rt.q/include/asm-i386/processor.h
===================================================================
--- linux-rt.q.orig/include/asm-i386/processor.h
+++ linux-rt.q/include/asm-i386/processor.h
@@ -128,7 +128,7 @@ extern void detect_ht(struct cpuinfo_x86
 static inline void detect_ht(struct cpuinfo_x86 *c) {}
 #endif
 
-static inline void native_cpuid(unsigned int *eax, unsigned int *ebx,
+static inline void fastcall native_cpuid(unsigned int *eax, unsigned int *ebx,
 					 unsigned int *ecx, unsigned int *edx)
 {
 	/* ecx is often an input as well as an output. */
@@ -602,7 +602,9 @@ static inline void load_esp0(struct tss_
  * clear %ecx since some cpus (Cyrix MII) do not set or clear %ecx
  * resulting in stale register contents being returned.
  */
-static inline void cpuid(unsigned int op, unsigned int *eax, unsigned int *ebx, unsigned int *ecx, unsigned int *edx)
+static inline void
+cpuid(unsigned int op, unsigned int *eax, unsigned int *ebx,
+      unsigned int *ecx, unsigned int *edx)
 {
 	*eax = op;
 	*ecx = 0;
@@ -610,8 +612,9 @@ static inline void cpuid(unsigned int op
 }
 
 /* Some CPUID calls want 'count' to be placed in ecx */
-static inline void cpuid_count(int op, int count, int *eax, int *ebx, int *ecx,
-			       int *edx)
+static inline void
+cpuid_count(int op, int count, unsigned int *eax, unsigned int *ebx,
+	    unsigned int *ecx, unsigned int *edx)
 {
 	*eax = op;
 	*ecx = count;
