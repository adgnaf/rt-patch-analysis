Subject: Latency tracer: Reset histogram when preempt_max_latency was reset

From: Carsten Emde <cbe@osadl.org>

When the histogram mode is active, it is not possible to reset the
histogram for a second one. Reset it, when preempt_max_latency was
reset.

Signed-off-by: Carsten Emde <cbe@osadl.org>

---
 include/linux/latency_hist.h |    1 +
 kernel/latency_hist.c        |   28 ++++++++++++++++++++++++++++
 kernel/latency_trace.c       |   15 +++++++++++++++
 3 files changed, 44 insertions(+)

Index: linux-rt.q/include/linux/latency_hist.h
===================================================================
--- linux-rt.q.orig/include/linux/latency_hist.h
+++ linux-rt.q/include/linux/latency_hist.h
@@ -23,6 +23,7 @@ enum {
 
 #ifdef CONFIG_LATENCY_HIST
 extern void latency_hist(int latency_type, int cpu, unsigned long latency);
+extern void latency_hist_reset(void);
 # define latency_hist_flag 1
 #else
 # define latency_hist(a,b,c) do { (void)(cpu); } while (0)
Index: linux-rt.q/kernel/latency_hist.c
===================================================================
--- linux-rt.q.orig/kernel/latency_hist.c
+++ linux-rt.q/kernel/latency_hist.c
@@ -264,3 +264,31 @@ static __init int latency_hist_init(void
 
 __initcall(latency_hist_init);
 
+
+#ifdef CONFIG_WAKEUP_LATENCY_HIST
+static void hist_reset(hist_data_t *hist)
+{
+	atomic_dec(&hist->hist_mode);
+
+	memset(hist->hist_array, 0, sizeof(hist->hist_array));
+	hist->beyond_hist_bound_samples = 0UL;
+	hist->min_lat = 0xFFFFFFFFUL;
+	hist->max_lat = 0UL;
+	hist->total_samples = 0UL;
+	hist->accumulate_lat = 0UL;
+	hist->avg_lat = 0UL;
+
+	atomic_inc(&hist->hist_mode);
+}
+
+void latency_hist_reset(void)
+{
+	int cpu;
+	hist_data_t *hist;
+
+	for_each_online_cpu(cpu) {
+		hist = &per_cpu(wakeup_latency_hist, cpu);
+		hist_reset(hist);
+	}
+}
+#endif
Index: linux-rt.q/kernel/latency_trace.c
===================================================================
--- linux-rt.q.orig/kernel/latency_trace.c
+++ linux-rt.q/kernel/latency_trace.c
@@ -2182,6 +2182,8 @@ void notrace trace_preempt_exit_idle(voi
  */
 #ifdef CONFIG_WAKEUP_TIMING
 
+unsigned long last_preempt_max_latency;
+
 static void notrace
 check_wakeup_timing(struct cpu_trace *tr, unsigned long parent_eip,
 		    unsigned long *flags)
@@ -2209,6 +2211,19 @@ check_wakeup_timing(struct cpu_trace *tr
 	if (!report_latency(delta))
 		goto out;
 
+#ifdef CONFIG_WAKEUP_LATENCY_HIST
+	/*
+	 * Was preempt_max_latency reset?
+	 * If so, we reinitialize the latency histograms to keep them in sync.
+	 *
+	 * FIXME: Remove the poll and write our own procfs handler, so
+	 * we can trigger on the write to preempt_max_latency
+	 */
+	if (last_preempt_max_latency > 0 && preempt_max_latency == 0)
+		latency_hist_reset();
+	last_preempt_max_latency = preempt_max_latency;
+#endif
+
 	____trace(smp_processor_id(), TRACE_FN, tr, CALLER_ADDR0, parent_eip,
 		  0, 0, 0, *flags);
 
